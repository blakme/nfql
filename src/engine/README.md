How to build and run
====================

	make
	./flowy < trace.flow

Filter Rule Flags
=================

Setting the size to 8, 16, 32 and 64 bit for a single filter value, the first
value (S1) or the second value (S2).

	RULE_8, RULE_16, RULE_32, RULE_64
	RULE_S1_8, RULE_S1_16, RULE_S1_32, RULE_S1_64
	RULE_S2_8, RULE_S2_16, RULE_S2_32, RULE_S2_64

Setting the delta type to no delta, absolute delta (comparison to first member
of the group) or relative delta (comparison to last member of the group):

	RULE_NO, RULE_ABS, RULE_REL

Specifying the comparison operation:

	RULE_EQ, RULE_NE, RULE_GT, RULE_LT, RULE_LE, RULE_GE

Overview of source files
========================

auto_assign.c
-------------

Generated by fun\_gen.py and contains the function assign\_fptr which fills the
`func` member of `struct grouper_rule` from flags stored in the `op` member of
that struct with their appropriate function pointers.

auto_comps.c
------------

Generated by fun\_gen.py and contains all comparison functions that are stored
as function pointers in the filter definitions for the filter, grouper,
groupfilter and merger.

auto_switch.c
-------------

Generated by fun\_gen.py and contains an alternative way to filter/group/merge
records by not evaluating the function pointers but by going through a switch
statement that evaluates the `op` member of the filter definition. This method
is being used in all functions specified in files ending in `_switch.c`.

filter_fptr.c
-------------

Contains the filter function definition using function pointers.

filter_switch.c
---------------

Contains the filter function definition using switch statements.

grouper.c
--------------

grouper_switch.c
----------------

groupfilter_switch.c
--------------------

groupfilter_fptr.c
------------------

merger_switch.c
---------------

merger.c
-------------

iterate.c
---------

treesearch.c
------------

utils.c
-------

Specifying the record attributes to compare
===========================================

Each record is stored a binary blob in memory. The values are stored in this
blob according to the flow-tools format version. To specify which value of a
record to compare to in a filter, offsets are set in the `data->offsets` member
that will represent correct offsets.

The second property that has to be set is the length of the attribute to be
compared and is set as the `op` member in the filter definition. See the filter
rule flags above.

Specifying filter conditions
============================

Filters are specified in conjunctive normal form (CNF), meaning they are stored
as a list of filters connected by a logical OR which themselves are connected
together by a logical AND. Example:

	(A∨B)∧(¬C∨D∨E)∧(¬E∨¬F)

Where each of A-F are `struct filter_rule` (filter), `struct grouper_rule`
(grouper), `struct gfilter_rule` (groupfilter) or `struct mfilter_rule`
(merger).

Specifying a query
==================

To specify a query, all members of `struct branch` have to be filled
except for the `filtered_groups` and `num_filtered_groups` members because
those store the result of the run of the branch. One has to specify as many
`struct branch` as there are branches.

`int branch\_id` - stores an integer identification of the branch (only for
debugging purposes)

`struct ft_data *` - contains a pointer to the records previously read by
`ft_open`.

`struct filter_rule **filter_rules`


Conjunctive normal form

comparison operators

all operators have a third delta or epsilon argument

equal         eq
not equal     ne
less than     lt
greater than  gt
less equal    le
greater equal ge

and
or
nand
nor
xor

allen time interval:

before           a_bf
after            a_af
meets            a_m
meets inverse    a_mi
overlaps         a_o
overlaps inverse a_oi
starts           a_s
starts inverse   a_si
during           a_d
during inverse   a_di
finishes         a_f
finishes inverse a_fi
equal            a_eq

for merger and gfilter: in

TODO: union aggregation

TODO: add option for filtering flow records immediately when they are read by
      testing them against the union of filter rules.

TODO: OR in rules

TODO: solve problem with over/underflows in comparison functions due to arguments exceeding uint64_t

TODO: does one ever want to compare two fields of different size?

TODO: as the pointer array of available records for grouping gets filled with
      NULL, after each completed grouping, resize the array, removing all
      NULL entries?

flow records are char arrays of fixed size in memory.

fields are extracted from these by offsets and sizes given in
filter/grouping/merging rules

for allen ops: sort by start and end time



filter_* (eq, ne, lt, gt, le, ge)

gfilter_*

aggr_*

mfilter_*
