<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>My Project: flowy.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">flowy.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;pthread.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &lt;errno.h&gt;</code><br/>
<code>#include &lt;stdbool.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="ftreader_8h_source.html">ftreader.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="flowy_8h_source.html">flowy.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="auto__comps_8h_source.html">auto_comps.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="utils_8h_source.html">utils.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for flowy.c:</div>
<div class="dyncontent">
<div class="center"><img src="flowy_8c__incl.png" border="0" usemap="#flowy_8c" alt=""/></div>
<map name="flowy_8c" id="flowy_8c">
<area shape="rect" id="node15" href="ftreader_8h.html" title="ftreader.h" alt="" coords="698,83,776,111"/><area shape="rect" id="node19" href="flowy_8h.html" title="flowy.h" alt="" coords="241,161,303,189"/><area shape="rect" id="node26" href="auto__comps_8h.html" title="auto_comps.h" alt="" coords="327,83,432,111"/><area shape="rect" id="node32" href="utils_8h.html" title="utils.h" alt="" coords="197,83,253,111"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flowy_8c.html#a369266c24eacffb87046522897a570d5">_GNU_SOURCE</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structgroup.html">group</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flowy_8c.html#aa035e73fc4c57220877467d56e352ee1">grouper</a> (char **filtered_records, size_t num_filtered_records, struct <a class="el" href="structgrouper__rule.html">grouper_rule</a> *group_modules, int num_group_modules, struct <a class="el" href="structgrouper__aggr.html">grouper_aggr</a> *<a class="el" href="structaggr.html">aggr</a>, size_t num_group_aggr, size_t *num_groups)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structgroup.html">group</a> ***&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flowy_8c.html#a3355351c471c88039bef49a658c06109">merger</a> (struct <a class="el" href="structgroup.html">group</a> ***filtered_groups, size_t *num_filtered_groups, int num_threads, struct <a class="el" href="structmerger__rule.html">merger_rule</a> *<a class="el" href="flowy_8c.html#ad16d168606f8e5927810013c8b566b3a">filter</a>, int num_filter_rules)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flowy_8c.html#ad16d168606f8e5927810013c8b566b3a">filter</a> (struct <a class="el" href="structft__data.html">ft_data</a> *data, struct <a class="el" href="structfilter__rule.html">filter_rule</a> *filter_rules, int num_filter_rules, size_t *num_filtered_records)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structgroup.html">group</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flowy_8c.html#a70f1dcae030371e286b96e41e7543dd6">group_filter</a> (struct <a class="el" href="structgroup.html">group</a> **groups, size_t num_groups, struct <a class="el" href="structgfilter__rule.html">gfilter_rule</a> *rules, size_t num_gfilter_rules, size_t *num_filtered_groups)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="flowy_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> (int argc, char **argv)</td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a369266c24eacffb87046522897a570d5"></a><!-- doxytag: member="flowy.c::_GNU_SOURCE" ref="a369266c24eacffb87046522897a570d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="merger__fptr_8c.html#a369266c24eacffb87046522897a570d5">_GNU_SOURCE</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ad16d168606f8e5927810013c8b566b3a"></a><!-- doxytag: member="flowy.c::filter" ref="ad16d168606f8e5927810013c8b566b3a" args="(struct ft_data *data, struct filter_rule *filter_rules, int num_filter_rules, size_t *num_filtered_records)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char** <a class="el" href="flowy_8c.html#ad16d168606f8e5927810013c8b566b3a">filter</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structft__data.html">ft_data</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfilter__rule.html">filter_rule</a> *&#160;</td>
          <td class="paramname"><em>filter_rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_filter_rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_filtered_records</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i, j;
    <span class="keywordtype">char</span> **filtered_records;

    *num_filtered_records = 0;
    filtered_records = (<span class="keywordtype">char</span> **)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *)**num_filtered_records);
    <span class="keywordflow">if</span> (filtered_records == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; data-&gt;<a class="code" href="structft__data.html#a0ee5c9e9e607138986705fe248e54e7b">num_records</a>; i++) {
        <span class="keywordflow">for</span> (j = 0; j &lt; num_filter_rules; j++) {
            <span class="keywordflow">if</span> (!filter_rules[j].func(data-&gt;<a class="code" href="structft__data.html#a2135250dffa8caedbb2bd265ec4a9858">records</a>[i], filter_rules[j].<a class="code" href="structfilter__rule.html#ae808db59ea5ef6037127ab92eec860bc">field_offset</a>, filter_rules[j].<a class="code" href="structfilter__rule.html#a58fec5582954b48c67bd0b91113581cc">value</a>, filter_rules[j].<a class="code" href="structfilter__rule.html#aa60920ee7afd35534481a141508e9a76">delta</a>))
                <span class="keywordflow">break</span>;
        }

        <span class="comment">// break if a rule did not return true</span>
        <span class="keywordflow">if</span> (j &lt; num_filter_rules)
            <span class="keywordflow">continue</span>;

        (*num_filtered_records)++;
        filtered_records = (<span class="keywordtype">char</span> **)realloc(filtered_records, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *)**num_filtered_records);
        <span class="keywordflow">if</span> (filtered_records == NULL) {
            perror(<span class="stringliteral">&quot;malloc&quot;</span>);
            exit(EXIT_FAILURE);
        }
        filtered_records[*num_filtered_records-1] = data-&gt;<a class="code" href="structft__data.html#a2135250dffa8caedbb2bd265ec4a9858">records</a>[i];
    }

    <span class="keywordflow">return</span> filtered_records;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a70f1dcae030371e286b96e41e7543dd6"></a><!-- doxytag: member="flowy.c::group_filter" ref="a70f1dcae030371e286b96e41e7543dd6" args="(struct group **groups, size_t num_groups, struct gfilter_rule *rules, size_t num_gfilter_rules, size_t *num_filtered_groups)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structgroup.html">group</a>** <a class="el" href="flowy_8c.html#a70f1dcae030371e286b96e41e7543dd6">group_filter</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structgroup.html">group</a> **&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgfilter__rule.html">gfilter_rule</a> *&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_gfilter_rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_filtered_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keywordtype">int</span> i, j;
    <span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **filtered_groups;

    *num_filtered_groups = 0;
    filtered_groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a> *)**num_filtered_groups);

    printf(<span class="stringliteral">&quot;foobar3\n&quot;</span>);
    <span class="keywordflow">for</span> (i = num_groups-1; i &gt; num_groups-10; i--) {
        printf(<span class="stringliteral">&quot;%p\n&quot;</span>, groups[i]);
        <span class="keywordflow">if</span> (groups[i] == NULL) {
            perror(<span class="stringliteral">&quot;found nil&quot;</span>);
            exit(EXIT_FAILURE);
        }
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; num_groups; i++) {
        <span class="keywordflow">for</span> (j = 0; j &lt; num_gfilter_rules; j++) {
            <span class="keywordflow">if</span> (!rules[j].func(groups[i], rules[j].field, rules[j].value, rules[j].delta))
                <span class="keywordflow">break</span>;
        }

        <span class="keywordflow">if</span> (j &lt; num_gfilter_rules) {
            free(groups[i]-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a>);
            free(groups[i]-&gt;<a class="code" href="structaggr.html">aggr</a>);
            free(groups[i]);
            groups[i] = NULL;
            <span class="keywordflow">continue</span>;
        }

        (*num_filtered_groups)++;
        filtered_groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **)realloc(filtered_groups, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a> *)**num_filtered_groups);
        filtered_groups[*num_filtered_groups-1] = groups[i];
    }

    filtered_groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **)realloc(filtered_groups, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a> *)**num_filtered_groups+1);
    <span class="keywordflow">if</span> (filtered_groups == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }
    filtered_groups[*num_filtered_groups] = groups[i];

    printf(<span class="stringliteral">&quot;foobar2\n&quot;</span>);
    <span class="keywordflow">for</span> (i = *num_filtered_groups-1; i &gt; *num_filtered_groups-10; i--) {
        printf(<span class="stringliteral">&quot;%p\n&quot;</span>, filtered_groups[i]);
        <span class="keywordflow">if</span> (filtered_groups[i] == NULL) {
            perror(<span class="stringliteral">&quot;found nil&quot;</span>);
            exit(EXIT_FAILURE);
        }
    }

    <span class="keywordflow">return</span> filtered_groups;
}
</pre></div>
</div>
</div>
<a class="anchor" id="aa035e73fc4c57220877467d56e352ee1"></a><!-- doxytag: member="flowy.c::grouper" ref="aa035e73fc4c57220877467d56e352ee1" args="(char **filtered_records, size_t num_filtered_records, struct grouper_rule *group_modules, int num_group_modules, struct grouper_aggr *aggr, size_t num_group_aggr, size_t *num_groups)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structgroup.html">group</a>** <a class="el" href="grouper__fptr_8c.html#aa035e73fc4c57220877467d56e352ee1">grouper</a> </td>
          <td>(</td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>filtered_records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_filtered_records</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgrouper__rule.html">grouper_rule</a> *&#160;</td>
          <td class="paramname"><em>group_modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_group_modules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structgrouper__aggr.html">grouper_aggr</a> *&#160;</td>
          <td class="paramname"><em>aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_group_aggr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **groups;
    <span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> *newgroup;
    <span class="keywordtype">int</span> i, j, k;
    <span class="keyword">struct </span><a class="code" href="structuniq__records__tree.html">uniq_records_tree</a> *uniq_records_trees;

    *num_groups = 0;
    groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a> *));

    <span class="keywordflow">if</span> (num_group_modules == 0) {
        <span class="keywordflow">for</span> (i = 0; i &lt; num_filtered_records; i++) {
            <span class="keywordflow">if</span> ((i&amp;1023)==0) {
                printf(<span class="stringliteral">&quot;\r%0.2f%% %d/%zd groups: %zd&quot;</span>, (i*100.0f)/num_filtered_records, i, num_filtered_records, *num_groups);
                fflush(stdout);
            }

            (*num_groups)++;
            groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **)realloc(groups, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a>*)**num_groups);
            newgroup = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> *)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a>));
            <span class="keywordflow">if</span> (newgroup == NULL) {
                perror(<span class="stringliteral">&quot;malloc&quot;</span>);
                exit(EXIT_FAILURE);
            }
            groups[*num_groups-1] = newgroup;
            newgroup-&gt;<a class="code" href="structgroup.html#a3606a1f9876a73c5541e4e19f2b3cbba">num_members</a> = 1;
            newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a> = (<span class="keywordtype">char</span> **)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
            newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a>[0] = filtered_records[i];
        }
    } <span class="keywordflow">else</span> {
        uniq_records_trees = <a class="code" href="grouper__fptr_8c.html#a286a39f0eb4a6f6cd878cb1d66dd274e">build_record_trees</a>(filtered_records, num_filtered_records, group_modules);

        <span class="keywordflow">for</span> (i = 0; i &lt; num_filtered_records; i++) {
            <span class="keywordflow">if</span> ((i&amp;1023)==0) {
                printf(<span class="stringliteral">&quot;\r%0.2f%% %d/%zd groups: %zd&quot;</span>, (i*100.0f)/num_filtered_records, i, num_filtered_records, *num_groups);
                fflush(stdout);
            }

            <span class="keywordflow">if</span> (filtered_records[i] == NULL)
                <span class="keywordflow">continue</span>;

            (*num_groups)++;
            groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> **)realloc(groups, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a>*)**num_groups);
            newgroup = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> *)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a>));
            <span class="keywordflow">if</span> (newgroup == NULL) {
                perror(<span class="stringliteral">&quot;malloc&quot;</span>);
                exit(EXIT_FAILURE);
            }
            groups[*num_groups-1] = newgroup;
            newgroup-&gt;<a class="code" href="structgroup.html#a3606a1f9876a73c5541e4e19f2b3cbba">num_members</a> = 1;
            newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a> = (<span class="keywordtype">char</span> **)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *));
            newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a>[0] = filtered_records[i];

            <span class="keywordflow">if</span> (num_group_modules == 0)
                <span class="keywordflow">continue</span>;

            <span class="comment">// search for left hand side of comparison in records ordered by right</span>
            <span class="comment">// hand side of comparison</span>
            <span class="keywordtype">char</span> ***record_iter = ((<span class="keyword">struct </span>tree_item_uint32_t *)<a class="code" href="utils_8c.html#a05060ff8f80698e127a541d6897a37fa">bsearch_r</a>(
                        filtered_records[i],
                        (<span class="keywordtype">void</span> *)uniq_records_trees[0].<a class="code" href="structuniq__records__tree.html#a5804158857fe19cae48836378cc109f7">uniq_records32</a>,
                        uniq_records_trees[0].<a class="code" href="structuniq__records__tree.html#ad29c48d8c32333c64850922e14f07653">num_uniq_records</a>,
                        <span class="keyword">sizeof</span>(<span class="keyword">struct </span>tree_item_uint32_t),
                        <a class="code" href="utils_8h.html#af52876511c1e1050b7760a0162b20879">comp_uint32_t_p</a>,
                        (void *)&amp;group_modules[0].field_offset1))-&gt;ptr;

            <span class="comment">// iterate until terminating NULL in sorted_records</span>
            <span class="keywordflow">for</span> (;*record_iter != NULL; record_iter++) {
                <span class="comment">// already processed record from filtered_records</span>
                <span class="keywordflow">if</span> (**record_iter == NULL)
                    <span class="keywordflow">continue</span>;

                <span class="comment">// do not group with itself</span>
                <span class="keywordflow">if</span> (**record_iter == filtered_records[i])
                    <span class="keywordflow">continue</span>;

                <span class="comment">// check all module filter rules for those two records</span>
                <span class="keywordflow">for</span> (k = 0; k &lt; num_group_modules; k++) {
                    <span class="keywordflow">if</span> (!group_modules[k].func(newgroup, group_modules[k].field_offset1,
                                **record_iter, group_modules[k].field_offset2, group_modules[k].delta))
                        <span class="keywordflow">break</span>;
                }

                <span class="comment">// first rule didnt match</span>
                <span class="keywordflow">if</span> (k == 0)
                    <span class="keywordflow">break</span>;

                <span class="comment">// one of the other rules didnt match</span>
                <span class="keywordflow">if</span> (k &lt; num_group_modules)
                    <span class="keywordflow">continue</span>;

                newgroup-&gt;<a class="code" href="structgroup.html#a3606a1f9876a73c5541e4e19f2b3cbba">num_members</a>++;
                newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a> = (<span class="keywordtype">char</span> **)realloc(newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a>, <span class="keyword">sizeof</span>(<span class="keywordtype">char</span> *)*newgroup-&gt;<a class="code" href="structgroup.html#a3606a1f9876a73c5541e4e19f2b3cbba">num_members</a>);
                newgroup-&gt;<a class="code" href="structgroup.html#a4bb58cf13aa5a2f653c18385ba11b008">members</a>[newgroup-&gt;<a class="code" href="structgroup.html#a3606a1f9876a73c5541e4e19f2b3cbba">num_members</a>-1] = **record_iter; <span class="comment">// assign entry in filtered_records to group</span>
                **record_iter = NULL; <span class="comment">// set entry in filtered_records to NULL</span>
            }

            filtered_records[i] = NULL;
        }

        <span class="comment">// free uniq_records_trees</span>
        free(uniq_records_trees[0].sorted_records);
        free(uniq_records_trees[0].uniq_records32);
        free(uniq_records_trees);
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; *num_groups; i++) {
        printf(<span class="stringliteral">&quot;%p\n&quot;</span>, groups[i]);
        groups[i]-&gt;<a class="code" href="structgroup.html#abf1076c6debaaa605fdcfc46ca0ee97d">aggr</a> = (<span class="keyword">struct </span>aggr *)malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> aggr)*num_group_aggr);
        <span class="keywordflow">if</span> (groups[i]-&gt;aggr == NULL) {
            perror(<span class="stringliteral">&quot;malloc&quot;</span>);
            exit(EXIT_FAILURE);
        }

        <span class="keywordflow">for</span> (j = 0; j &lt; num_group_aggr; j++) {
            groups[i]-&gt;<a class="code" href="structgroup.html#abf1076c6debaaa605fdcfc46ca0ee97d">aggr</a>[j] = aggr[j].<a class="code" href="structgrouper__aggr.html#a6c34e047d2d5ccfbcd1371703c4c04b1">func</a>(groups[i]-&gt;members, groups[i]-&gt;num_members, aggr[j].field_offset);
        }
    }

    printf(<span class="stringliteral">&quot;foobar5\n&quot;</span>);
    <span class="keywordflow">for</span> (i = *num_groups; i &gt; *num_groups-10; i--) {
        printf(<span class="stringliteral">&quot;%p\n&quot;</span>, groups[i]);
    }

    <span class="keywordflow">return</span> groups;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="flowy_8c_aa035e73fc4c57220877467d56e352ee1_cgraph.png" border="0" usemap="#flowy_8c_aa035e73fc4c57220877467d56e352ee1_cgraph" alt=""/></div>
<map name="flowy_8c_aa035e73fc4c57220877467d56e352ee1_cgraph" id="flowy_8c_aa035e73fc4c57220877467d56e352ee1_cgraph">
<area shape="rect" id="node3" href="grouper__fptr_8c.html#a286a39f0eb4a6f6cd878cb1d66dd274e" title="build_record_trees" alt="" coords="121,5,253,33"/><area shape="rect" id="node7" href="utils_8c.html#a05060ff8f80698e127a541d6897a37fa" title="bsearch_r" alt="" coords="146,57,227,85"/><area shape="rect" id="node5" href="utils_8h.html#af6db05e0f8ec6dc038079b4d7db31714" title="comp_uint32_t" alt="" coords="302,5,410,33"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3c04138a5bfe5d72780bb7e82a18e627"></a><!-- doxytag: member="flowy.c::main" ref="a3c04138a5bfe5d72780bb7e82a18e627" args="(int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="flowy_8c.html#a3c04138a5bfe5d72780bb7e82a18e627">main</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structft__data.html">ft_data</a> *data;
    <span class="keywordtype">int</span> num_threads;
    <span class="keywordtype">int</span> i, ret;
    pthread_t *thread_ids;
    pthread_attr_t *thread_attrs;
    <span class="keyword">struct </span><a class="code" href="structbranch__info.html">branch_info</a> *binfos;
    <span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> ***filtered_groups;
    <span class="keywordtype">size_t</span> *num_filtered_groups;
    <span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> ***group_tuples;

    num_threads = 2;

    data = <a class="code" href="ftreader_8c.html#a02ab4173607a2c21aeb6f5fc1ae15363">ft_open</a>(STDIN_FILENO);

    binfos = (<span class="keyword">struct </span><a class="code" href="structbranch__info.html">branch_info</a> *)calloc(num_threads, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structbranch__info.html">branch_info</a>));
    <span class="keywordflow">if</span> (binfos == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    <span class="comment">/*</span>
<span class="comment">     * custom rules</span>
<span class="comment">     */</span>

    <span class="keyword">struct </span><a class="code" href="structfilter__rule.html">filter_rule</a> filter_rules_branch1[1] = {
        { data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstport, 80, 0, <a class="code" href="auto__comps_8c.html#abe66a806889783e72d526d2fe57486e5">filter_eq_uint16_t</a> },
    };

    <span class="keyword">struct </span><a class="code" href="structgrouper__rule.html">grouper_rule</a> group_module_branch1[2] = {
        { data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcaddr, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcaddr, 0, <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba882cd1ffb3c897bbab633e4bf8acf9a0">RULE_EQ</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4a92c264af23f5d31efd5dd89b1fe322">RULE_NO</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f331461d71b5f030ae940a88bf6f571">RULE_S2_32</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba89d1b00942dea18077de3d3a8ac72cb9">RULE_S1_32</a>, NULL },
        { data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstaddr, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstaddr, 0, <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba882cd1ffb3c897bbab633e4bf8acf9a0">RULE_EQ</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4a92c264af23f5d31efd5dd89b1fe322">RULE_NO</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f331461d71b5f030ae940a88bf6f571">RULE_S2_32</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba89d1b00942dea18077de3d3a8ac72cb9">RULE_S1_32</a>, NULL },
<span class="comment">//        { data-&gt;offsets.Last, data-&gt;offsets.First, 1, grouper_lt_uint32_t_rel }</span>
    };

    <span class="keyword">struct </span><a class="code" href="structgrouper__aggr.html">grouper_aggr</a> group_aggr_branch1[4] = {
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcaddr, <a class="code" href="auto__comps_8c.html#a8fcddd342e8b5414c35c812ebdda2657">aggr_static_uint32_t</a> },
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstaddr, <a class="code" href="auto__comps_8c.html#a8fcddd342e8b5414c35c812ebdda2657">aggr_static_uint32_t</a> },
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dOctets, <a class="code" href="auto__comps_8c.html#a7319e6948abebe50c28a6b3875dabbcd">aggr_sum_uint32_t</a> },
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.tcp_flags, <a class="code" href="auto__comps_8c.html#a911af4719dddf2e7b3a35f612a9dcb7d">aggr_or_uint16_t</a> }
    };

    <span class="keyword">struct </span><a class="code" href="structgfilter__rule.html">gfilter_rule</a> gfilter_branch1[0] = {
    };

    binfos[0].<a class="code" href="structbranch__info.html#a6cbcf2bcb1c568d814ed65d44d3863f3">branch_id</a> = 0;
    binfos[0].<a class="code" href="structbranch__info.html#a349eec62cfbb3890aa0610e0d983f3b1">data</a> = data;
    binfos[0].<a class="code" href="structbranch__info.html#a7e37880a544c6af0c068187b80ec3215">filter_rules</a> = filter_rules_branch1;
    binfos[0].<a class="code" href="structbranch__info.html#ad375459bf2bd609517c0927826878cdf">num_filter_rules</a> = 0;
    binfos[0].<a class="code" href="structbranch__info.html#a36d8f1bdb8c8fa4dafe7292b885ac066">group_modules</a> = group_module_branch1;
    binfos[0].<a class="code" href="structbranch__info.html#a55739e63096133c35770d4301e0b1707">num_group_modules</a> = 2;
    binfos[0].<a class="code" href="structbranch__info.html#a1248264340222f00113692e6692d1ee7">aggr</a> = group_aggr_branch1;
    binfos[0].<a class="code" href="structbranch__info.html#a6d6ce4f15c0bf68d3ae10a23877de8c1">num_aggr</a> = 4;
    binfos[0].<a class="code" href="structbranch__info.html#a93bb8a42b423d6b1215f416f466f583d">gfilter_rules</a> = gfilter_branch1;
    binfos[0].<a class="code" href="structbranch__info.html#ad65fbdeee3c34759d28a42fb653ddd19">num_gfilter_rules</a> = 0;

    <span class="keyword">struct </span><a class="code" href="structfilter__rule.html">filter_rule</a> filter_rules_branch2[1] = {
        { data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcport, 80, 0, <a class="code" href="auto__comps_8c.html#abe66a806889783e72d526d2fe57486e5">filter_eq_uint16_t</a> },
    };

    <span class="keyword">struct </span><a class="code" href="structgrouper__rule.html">grouper_rule</a> group_module_branch2[2] = {
        { data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcaddr, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcaddr, 0, <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba882cd1ffb3c897bbab633e4bf8acf9a0">RULE_EQ</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4a92c264af23f5d31efd5dd89b1fe322">RULE_NO</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f331461d71b5f030ae940a88bf6f571">RULE_S2_32</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba89d1b00942dea18077de3d3a8ac72cb9">RULE_S1_32</a>, NULL },
        { data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstaddr, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstaddr, 0, <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba882cd1ffb3c897bbab633e4bf8acf9a0">RULE_EQ</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba4a92c264af23f5d31efd5dd89b1fe322">RULE_NO</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba8f331461d71b5f030ae940a88bf6f571">RULE_S2_32</a> | <a class="code" href="flowy_8h.html#a06fc87d81c62e9abb8790b6e5713c55ba89d1b00942dea18077de3d3a8ac72cb9">RULE_S1_32</a>, NULL },
<span class="comment">//        { data-&gt;offsets.Last, data-&gt;offsets.First, 1, grouper_lt_uint32_t_rel },</span>
    };

    <span class="keyword">struct </span><a class="code" href="structgrouper__aggr.html">grouper_aggr</a> group_aggr_branch2[4] = {
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.srcaddr, <a class="code" href="auto__comps_8c.html#a8fcddd342e8b5414c35c812ebdda2657">aggr_static_uint32_t</a> },
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dstaddr, <a class="code" href="auto__comps_8c.html#a8fcddd342e8b5414c35c812ebdda2657">aggr_static_uint32_t</a> },
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.dOctets, <a class="code" href="auto__comps_8c.html#a7319e6948abebe50c28a6b3875dabbcd">aggr_sum_uint32_t</a> },
        { 0, data-&gt;<a class="code" href="structft__data.html#a4e2b828b9122744d5cb7fb509d849679">offsets</a>.tcp_flags, <a class="code" href="auto__comps_8c.html#a911af4719dddf2e7b3a35f612a9dcb7d">aggr_or_uint16_t</a> }
    };

    <span class="keyword">struct </span><a class="code" href="structgfilter__rule.html">gfilter_rule</a> gfilter_branch2[0] = {
    };

    binfos[1].<a class="code" href="structbranch__info.html#a6cbcf2bcb1c568d814ed65d44d3863f3">branch_id</a> = 1;
    binfos[1].<a class="code" href="structbranch__info.html#a349eec62cfbb3890aa0610e0d983f3b1">data</a> = data;
    binfos[1].<a class="code" href="structbranch__info.html#a7e37880a544c6af0c068187b80ec3215">filter_rules</a> = filter_rules_branch2;
    binfos[1].<a class="code" href="structbranch__info.html#ad375459bf2bd609517c0927826878cdf">num_filter_rules</a> = 1;
    binfos[1].<a class="code" href="structbranch__info.html#a36d8f1bdb8c8fa4dafe7292b885ac066">group_modules</a> = group_module_branch2;
    binfos[1].<a class="code" href="structbranch__info.html#a55739e63096133c35770d4301e0b1707">num_group_modules</a> = 2;
    binfos[1].<a class="code" href="structbranch__info.html#a1248264340222f00113692e6692d1ee7">aggr</a> = group_aggr_branch2;
    binfos[1].<a class="code" href="structbranch__info.html#a6d6ce4f15c0bf68d3ae10a23877de8c1">num_aggr</a> = 4;
    binfos[1].<a class="code" href="structbranch__info.html#a93bb8a42b423d6b1215f416f466f583d">gfilter_rules</a> = gfilter_branch2;
    binfos[1].<a class="code" href="structbranch__info.html#ad65fbdeee3c34759d28a42fb653ddd19">num_gfilter_rules</a> = 0;

    <span class="comment">/*</span>
<span class="comment">     * fill the func attribute of grouper rules</span>
<span class="comment">     */</span>
    <a class="code" href="auto__assign_8c.html#a25504d2edbe933b8c1423b80a7d15922">assign_fptr</a>(binfos, num_threads);

    <span class="comment">/*</span>
<span class="comment">     * SPLITTER</span>
<span class="comment">     *</span>
<span class="comment">     * (mostly pthread stuff)</span>
<span class="comment">     */</span>

    thread_ids = (pthread_t *)calloc(num_threads, <span class="keyword">sizeof</span>(pthread_t));
    <span class="keywordflow">if</span> (thread_ids == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    thread_attrs = (pthread_attr_t *)calloc(num_threads, <span class="keyword">sizeof</span>(pthread_attr_t));
    <span class="keywordflow">if</span> (thread_attrs == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    filtered_groups = (<span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> ***)malloc(num_threads*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <a class="code" href="structgroup.html">group</a> **));
    <span class="keywordflow">if</span> (filtered_groups == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    num_filtered_groups = (<span class="keywordtype">size_t</span> *)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>)*num_threads);
    <span class="keywordflow">if</span> (num_filtered_groups == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; num_threads; i++) {
        ret = pthread_attr_init(&amp;thread_attrs[i]);
        <span class="keywordflow">if</span> (ret != 0) {
            errno = ret;
            perror(<span class="stringliteral">&quot;pthread_attr_init&quot;</span>);
            exit(EXIT_FAILURE);
        }

        ret = pthread_create(&amp;thread_ids[i], &amp;thread_attrs[i], &amp;branch_start, (<span class="keywordtype">void</span> *)(&amp;binfos[i]));
        <span class="keywordflow">if</span> (ret != 0) {
            errno = ret;
            perror(<span class="stringliteral">&quot;pthread_create&quot;</span>);
            exit(EXIT_FAILURE);
        }

        ret = pthread_attr_destroy(&amp;thread_attrs[i]);
        <span class="keywordflow">if</span> (ret != 0) {
            errno = ret;
            perror(<span class="stringliteral">&quot;pthread_attr_destroy&quot;</span>);
            exit(EXIT_FAILURE);
        }
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; num_threads; i++) {
        ret = pthread_join(thread_ids[i], NULL);
        <span class="keywordflow">if</span> (ret != 0) {
            errno = ret;
            perror(<span class="stringliteral">&quot;pthread_join&quot;</span>);
            exit(EXIT_FAILURE);
        }

        num_filtered_groups[i] = binfos[i].<a class="code" href="structbranch__info.html#a2a8dfe3330c889d7be215c3bbbeef43a">num_filtered_groups</a>;
        filtered_groups[i] = binfos[i].<a class="code" href="structbranch__info.html#a4645514f5b85b8acdedebc78998a11d4">filtered_groups</a>;
        printf(<span class="stringliteral">&quot;%zd\n&quot;</span>, num_filtered_groups[i]);
    }

    free(thread_ids);
    free(thread_attrs);
    free(binfos);

    <span class="comment">/*</span>
<span class="comment">     * MERGER</span>
<span class="comment">     */</span>

    <span class="keyword">struct </span><a class="code" href="structmerger__rule.html">merger_rule</a> mfilter[2] = {
        { 0, 0, 1, 1, 0, <a class="code" href="auto__comps_8c.html#a7fa3f95416b286f57a6d0e80b6f74ab3">merger_eq</a> },
        { 0, 2, 1, 2, 0, <a class="code" href="auto__comps_8c.html#a8ca2e0d7ab58e3ae9ecbd17d0cb0fd60">merger_lt</a> },
    };

    printf(<span class="stringliteral">&quot;foobar1\n&quot;</span>);
    <span class="keywordflow">for</span> (i = num_filtered_groups[0]-1; i &gt; num_filtered_groups[0]-10; i--) {
        printf(<span class="stringliteral">&quot;%p\n&quot;</span>, filtered_groups[0][i]);
        <span class="keywordflow">if</span> (filtered_groups[0][i] == NULL) {
            perror(<span class="stringliteral">&quot;found nil&quot;</span>);
            exit(EXIT_FAILURE);
        }
    }

    group_tuples = <a class="code" href="flowy_8c.html#a3355351c471c88039bef49a658c06109">merger</a>(filtered_groups, num_filtered_groups, num_threads, mfilter, 2);

    free(group_tuples);

    <span class="comment">/*</span>
<span class="comment">     * UNGROUPER</span>
<span class="comment">     */</span>

    <span class="comment">// TODO: free group_collections at some point</span>

    exit(EXIT_SUCCESS);
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph.png" border="0" usemap="#flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph" alt=""/></div>
<map name="flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph" id="flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph">
<area shape="rect" id="node3" href="ftreader_8c.html#a02ab4173607a2c21aeb6f5fc1ae15363" title="ft_open" alt="" coords="142,759,208,787"/><area shape="rect" id="node5" href="auto__comps_8c.html#abe66a806889783e72d526d2fe57486e5" title="filter_eq_uint16_t" alt="" coords="113,811,236,839"/><area shape="rect" id="node7" href="auto__comps_8c.html#a8fcddd342e8b5414c35c812ebdda2657" title="aggr_static_uint32_t" alt="" coords="104,863,245,891"/><area shape="rect" id="node9" href="auto__comps_8c.html#a7319e6948abebe50c28a6b3875dabbcd" title="aggr_sum_uint32_t" alt="" coords="107,915,242,943"/><area shape="rect" id="node11" href="auto__comps_8c.html#a911af4719dddf2e7b3a35f612a9dcb7d" title="aggr_or_uint16_t" alt="" coords="114,967,236,995"/><area shape="rect" id="node13" href="auto__assign_8c.html#a25504d2edbe933b8c1423b80a7d15922" title="assign_fptr" alt="" coords="131,1019,218,1047"/><area shape="rect" id="node95" href="auto__comps_8c.html#a7fa3f95416b286f57a6d0e80b6f74ab3" title="merger_eq" alt="" coords="132,1071,218,1099"/><area shape="rect" id="node97" href="auto__comps_8c.html#a8ca2e0d7ab58e3ae9ecbd17d0cb0fd60" title="merger_lt" alt="" coords="136,1123,213,1151"/><area shape="rect" id="node99" href="flowy_8c.html#a3355351c471c88039bef49a658c06109" title="merger" alt="" coords="143,1175,206,1203"/><area shape="rect" id="node15" href="auto__comps_8c.html#a8b7bf3e9626342ab6d3af6011238a7d5" title="grouper_eq_uint8_t_uint8_t_abs" alt="" coords="301,5,515,33"/><area shape="rect" id="node17" href="auto__comps_8c.html#a4d51c878486fc1b8a55f6c1319a256a9" title="grouper_eq_uint8_t_uint8_t_rel" alt="" coords="305,57,511,85"/><area shape="rect" id="node19" href="auto__comps_8c.html#a896c289ecb00fb7a4a0b1fb6fa4510ae" title="grouper_eq_uint8_t_uint8_t_no" alt="" coords="305,109,511,137"/><area shape="rect" id="node21" href="auto__comps_8c.html#a832a3f0dc841c1dfb637345e8d786319" title="grouper_eq_uint8_t_uint16_t_abs" alt="" coords="298,161,518,189"/><area shape="rect" id="node23" href="auto__comps_8c.html#abf0f8ec847f95c3b44945cf9a4f42ae0" title="grouper_eq_uint8_t_uint16_t_rel" alt="" coords="301,213,515,241"/><area shape="rect" id="node25" href="auto__comps_8c.html#aa7ad7ff2012ed8e22f5211ee377d53e8" title="grouper_eq_uint8_t_uint16_t_no" alt="" coords="301,265,515,293"/><area shape="rect" id="node27" href="auto__comps_8c.html#ad5fa627b3c4c8d4b6136a7de5a9aa541" title="grouper_eq_uint8_t_uint32_t_abs" alt="" coords="298,317,518,345"/><area shape="rect" id="node29" href="auto__comps_8c.html#aceb4005da085470f823aaa9880d0e9ba" title="grouper_eq_uint8_t_uint32_t_rel" alt="" coords="301,369,515,397"/><area shape="rect" id="node31" href="auto__comps_8c.html#a63ce8272de0055b09cbe4358b936abdc" title="grouper_eq_uint8_t_uint32_t_no" alt="" coords="301,421,515,449"/><area shape="rect" id="node33" href="auto__comps_8c.html#a3494caa14ffff3a3fb0725bc623bfd4e" title="grouper_eq_uint8_t_uint64_t_abs" alt="" coords="298,473,518,501"/><area shape="rect" id="node35" href="auto__comps_8c.html#abc3dc36d79e5b56acc6b5e74f9626f83" title="grouper_eq_uint8_t_uint64_t_rel" alt="" coords="301,525,515,553"/><area shape="rect" id="node37" href="auto__comps_8c.html#a0918c3ac968882c42d559e70037e5661" title="grouper_eq_uint8_t_uint64_t_no" alt="" coords="301,577,515,605"/><area shape="rect" id="node39" href="auto__comps_8c.html#a2cd406afab22d54ec9b93a56eece6881" title="grouper_eq_uint16_t_uint8_t_abs" alt="" coords="298,629,518,657"/><area shape="rect" id="node41" href="auto__comps_8c.html#a644bc14f9414a57e4b1e0f13d5185957" title="grouper_eq_uint16_t_uint8_t_rel" alt="" coords="301,681,515,709"/><area shape="rect" id="node43" href="auto__comps_8c.html#afa2678fdcc9942d90bf0c2766997574f" title="grouper_eq_uint16_t_uint8_t_no" alt="" coords="301,733,515,761"/><area shape="rect" id="node45" href="auto__comps_8c.html#a2dd936ce010adde1563eac3d5e4dc439" title="grouper_eq_uint16_t_uint16_t_abs" alt="" coords="294,785,522,813"/><area shape="rect" id="node47" href="auto__comps_8c.html#a197d15432e66b323498be478d6accacf" title="grouper_eq_uint16_t_uint16_t_rel" alt="" coords="297,837,519,865"/><area shape="rect" id="node49" href="auto__comps_8c.html#ad5e855cb7d792cc0bc1cda93a0cc8fa2" title="grouper_eq_uint16_t_uint16_t_no" alt="" coords="297,889,519,917"/><area shape="rect" id="node51" href="auto__comps_8c.html#a11a6767b37cd7d1cf7b3312d48369d90" title="grouper_eq_uint16_t_uint32_t_abs" alt="" coords="294,941,522,969"/><area shape="rect" id="node53" href="auto__comps_8c.html#ac5ce06cd834d8cae06500bad22952b17" title="grouper_eq_uint16_t_uint32_t_rel" alt="" coords="297,993,519,1021"/><area shape="rect" id="node55" href="auto__comps_8c.html#a99597986e2d60f99ffb10bcb14cf71f2" title="grouper_eq_uint16_t_uint32_t_no" alt="" coords="297,1045,519,1073"/><area shape="rect" id="node57" href="auto__comps_8c.html#add8d3dcfae68a6eb5e18e5dcb4ca45ef" title="grouper_eq_uint16_t_uint64_t_abs" alt="" coords="294,1097,522,1125"/><area shape="rect" id="node59" href="auto__comps_8c.html#ac68646e6b15426c50c804fb7d98e447c" title="grouper_eq_uint16_t_uint64_t_rel" alt="" coords="297,1149,519,1177"/><area shape="rect" id="node61" href="auto__comps_8c.html#afb11f7bc34da446cda464ed3c64a32f4" title="grouper_eq_uint16_t_uint64_t_no" alt="" coords="297,1201,519,1229"/><area shape="rect" id="node63" href="auto__comps_8c.html#a5c02c1d349ead15eb937c66d0d93110e" title="grouper_eq_uint32_t_uint8_t_abs" alt="" coords="298,1253,518,1281"/><area shape="rect" id="node65" href="auto__comps_8c.html#a027f0ba98c50eba45fbc5d404b37e0c0" title="grouper_eq_uint32_t_uint8_t_rel" alt="" coords="301,1305,515,1333"/><area shape="rect" id="node67" href="auto__comps_8c.html#aee47bbece5a8f114226b61cb0e2975a0" title="grouper_eq_uint32_t_uint8_t_no" alt="" coords="301,1357,515,1385"/><area shape="rect" id="node69" href="auto__comps_8c.html#acaa064965f9888264c47e2211a7ebb06" title="grouper_eq_uint32_t_uint16_t_abs" alt="" coords="294,1409,522,1437"/><area shape="rect" id="node71" href="auto__comps_8c.html#a6340d3025ee548fbef914e80f1a3e42c" title="grouper_eq_uint32_t_uint16_t_rel" alt="" coords="297,1461,519,1489"/><area shape="rect" id="node73" href="auto__comps_8c.html#a624a22a34ce2ef4b1e92b737dc38f83c" title="grouper_eq_uint32_t_uint16_t_no" alt="" coords="297,1513,519,1541"/><area shape="rect" id="node75" href="auto__comps_8c.html#ae3f3581900a4aac980982f03114208b9" title="grouper_eq_uint32_t_uint32_t_abs" alt="" coords="294,1565,522,1593"/><area shape="rect" id="node77" href="auto__comps_8c.html#a513c6a183f78d46a1074f65c7c2191b4" title="grouper_eq_uint32_t_uint32_t_rel" alt="" coords="297,1617,519,1645"/><area shape="rect" id="node79" href="auto__comps_8c.html#a1e0b2321e852e998e76148b0b63d8901" title="grouper_eq_uint32_t_uint32_t_no" alt="" coords="297,1669,519,1697"/><area shape="rect" id="node81" href="auto__comps_8c.html#ad1cd43c09bfb916ef7b42501efd1e387" title="grouper_eq_uint32_t_uint64_t_abs" alt="" coords="294,1721,522,1749"/><area shape="rect" id="node83" href="auto__comps_8c.html#a13a69148a9e32d5b5cefc88187c9bc0f" title="grouper_eq_uint32_t_uint64_t_rel" alt="" coords="297,1773,519,1801"/><area shape="rect" id="node85" href="auto__comps_8c.html#a947c0dcd3e74b71ef5c276e5ed083185" title="grouper_eq_uint32_t_uint64_t_no" alt="" coords="297,1825,519,1853"/><area shape="rect" id="node87" href="auto__comps_8c.html#a66e867b94460152f011de9fa9c8b565f" title="grouper_eq_uint64_t_uint8_t_abs" alt="" coords="298,1877,518,1905"/><area shape="rect" id="node89" href="auto__comps_8c.html#a17061e3e40610f866d52f1067314978c" title="grouper_eq_uint64_t_uint8_t_rel" alt="" coords="301,1929,515,1957"/><area shape="rect" id="node91" href="auto__comps_8c.html#a8faf2a4dd7798ba1fe3b785fd42c2cbf" title="grouper_eq_uint64_t_uint8_t_no" alt="" coords="301,1981,515,2009"/><area shape="rect" id="node93" href="auto__comps_8c.html#ab8bfbedceb8b30985dbbb7c6e4a17a22" title="grouper_eq_uint64_t_uint16_t_abs" alt="" coords="294,2033,522,2061"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a3355351c471c88039bef49a658c06109"></a><!-- doxytag: member="flowy.c::merger" ref="a3355351c471c88039bef49a658c06109" args="(struct group ***filtered_groups, size_t *num_filtered_groups, int num_threads, struct merger_rule *filter, int num_filter_rules)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structgroup.html">group</a>*** <a class="el" href="merger__fptr_8c.html#a3355351c471c88039bef49a658c06109">merger</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structgroup.html">group</a> ***&#160;</td>
          <td class="paramname"><em>filtered_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_filtered_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structmerger__rule.html">merger_rule</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_filter_rules</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [read]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<div class="fragment"><pre class="fragment">{
    <span class="keyword">struct </span><a class="code" href="structgroup.html">group</a> ***group_tuples;
<span class="comment">//    int num_group_tuples;</span>
<span class="comment">//    struct group **temp_tuple;</span>
<span class="comment">//    int i, j;</span>
    <span class="keywordtype">int</span> i;
    <span class="keyword">struct </span><a class="code" href="structpermut__iter.html">permut_iter</a> *iter;
    <span class="keywordtype">size_t</span> *<a class="code" href="structpermut__iter.html#aa3c8cdc4be5fba6e7d7b36f748710706">offsets</a>;

    offsets = (<span class="keywordtype">size_t</span> *)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">size_t</span>)*num_threads);
    <span class="keywordflow">if</span> (offsets == NULL) {
        perror(<span class="stringliteral">&quot;malloc&quot;</span>);
        exit(EXIT_FAILURE);
    }

    <span class="keywordflow">for</span> (i = 0; i &lt; num_threads; i++) offsets[i] = 0;

    iter = <a class="code" href="iterate_8c.html#a6d88d48d220e95a90623fd364a7ff51b">iter_init</a>(offsets, num_filtered_groups, num_threads);

    printf(<span class="stringliteral">&quot;foobar\n&quot;</span>);
    <span class="keywordflow">for</span> (i = num_filtered_groups[0]-1; i &gt; num_filtered_groups[0]-10; i--) {
        printf(<span class="stringliteral">&quot;%p\n&quot;</span>, filtered_groups[0][i]);
        <span class="keywordflow">if</span> (filtered_groups[0][i] == NULL) {
            perror(<span class="stringliteral">&quot;is NULL&quot;</span>);
            exit(EXIT_FAILURE);
        }
    }

    <span class="keywordflow">do</span> {
        <span class="comment">// break if any of the groups is already grouped</span>
        <span class="keywordflow">for</span> (i = 0; i &lt; num_threads; i++) {
            <span class="keywordflow">if</span> (filtered_groups[i][iter-&gt;<a class="code" href="structpermut__iter.html#a0f17d538587268e87ee958bb52b81e81">array</a>[i]] == NULL) <span class="keywordflow">goto</span> cont;
        }

        <span class="keywordflow">for</span> (i = 0; i &lt; num_filter_rules; i++) {
            printf(<span class="stringliteral">&quot;%p\n&quot;</span>, filtered_groups[filter[i].branch1][iter-&gt;<a class="code" href="structpermut__iter.html#a0f17d538587268e87ee958bb52b81e81">array</a>[filter[i].<a class="code" href="structmerger__rule.html#a7ec6995cf6218808af955a106bb5473e">branch1</a>]]);
            printf(<span class="stringliteral">&quot;%p\n&quot;</span>, filtered_groups[filter[i].branch1][iter-&gt;<a class="code" href="structpermut__iter.html#a0f17d538587268e87ee958bb52b81e81">array</a>[filter[i].<a class="code" href="structmerger__rule.html#a7ec6995cf6218808af955a106bb5473e">branch1</a>]]-&gt;<a class="code" href="structgroup.html#abf1076c6debaaa605fdcfc46ca0ee97d">aggr</a>);
            <span class="comment">/*</span>
<span class="comment">            if (!filter[i].func(filtered_groups[filter[i].branch1][iter-&gt;array[filter[i].branch1]], filter[i].field1,</span>
<span class="comment">                                filtered_groups[filter[i].branch2][iter-&gt;array[filter[i].branch2]], filter[i].field2,</span>
<span class="comment">                                filter[i].delta)) goto cont;</span>
<span class="comment">                                */</span>
        }
<span class="comment">/*</span>
<span class="comment">        for (i = 0; i &lt; num_threads; i++) {</span>
<span class="comment">            printf(&quot;%zd &quot;, iter-&gt;array[i]);</span>
<span class="comment">        }</span>
<span class="comment">        printf(&quot;\n&quot;);</span>
<span class="comment">        */</span>

cont:   <span class="keywordflow">continue</span>;
    } <span class="keywordflow">while</span> (<a class="code" href="iterate_8c.html#a38a5dc6c2c0cc8a9d328a076e92e2d52">iter_next</a>(iter));

    printf(<span class="stringliteral">&quot;foobar\n&quot;</span>);
    group_tuples = NULL;
<span class="comment">//    num_group_tuples = 0;</span>

<span class="comment">/*</span>
<span class="comment">    for (i = 0; filtered_groups[0][i]-&gt;aggr != NULL; i++) {</span>
<span class="comment">        for (j = 0; filtered_groups[1][j]-&gt;aggr != NULL; j++) {</span>
<span class="comment">            if (!filter[0].func(filtered_groups[0][i], filter[0].field1, filtered_groups[1][j], filter[0].field2, filter[0].delta)</span>
<span class="comment">                    || !filter[1].func(filtered_groups[0][i], filter[1].field1, filtered_groups[1][j], filter[1].field2, filter[1].delta)</span>
<span class="comment">                    )</span>
<span class="comment">                continue;</span>
<span class="comment"></span>
<span class="comment">            temp_tuple = (struct group **)malloc(sizeof(struct group *)*num_threads);</span>
<span class="comment">            if (temp_tuple == NULL) {</span>
<span class="comment">                perror(&quot;malloc&quot;);</span>
<span class="comment">                exit(EXIT_FAILURE);</span>
<span class="comment">            }</span>
<span class="comment"></span>
<span class="comment">            temp_tuple[0] = filtered_groups[0][i];</span>
<span class="comment">            temp_tuple[1] = filtered_groups[1][j];</span>
<span class="comment"></span>
<span class="comment">            group_tuples = (struct group ***)realloc(group_tuples, sizeof(struct group**)*(num_group_tuples+1));</span>
<span class="comment">            1if (group_tuples == NULL) {</span>
<span class="comment">                perror(&quot;malloc&quot;);</span>
<span class="comment">                exit(EXIT_FAILURE);</span>
<span class="comment">            }</span>
<span class="comment"></span>
<span class="comment">            group_tuples[num_group_tuples] = temp_tuple;</span>
<span class="comment">            num_group_tuples++;</span>
<span class="comment">        }</span>
<span class="comment">    }</span>
<span class="comment"></span>
<span class="comment">    group_tuples = (struct group ***)realloc(group_tuples, sizeof(struct group**)*(num_group_tuples+1));</span>
<span class="comment">    if (group_tuples == NULL) {</span>
<span class="comment">        perror(&quot;malloc&quot;);</span>
<span class="comment">        exit(EXIT_FAILURE);</span>
<span class="comment">    }</span>
<span class="comment">    group_tuples[num_group_tuples] = NULL;</span>
<span class="comment"></span>
<span class="comment">    printf(&quot;number of group tuples: %d\n&quot;, num_group_tuples);</span>
<span class="comment"></span>
<span class="comment">*/</span>
    <span class="keywordflow">return</span> group_tuples;
}
</pre></div>
<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="flowy_8c_a3355351c471c88039bef49a658c06109_cgraph.png" border="0" usemap="#flowy_8c_a3355351c471c88039bef49a658c06109_cgraph" alt=""/></div>
<map name="flowy_8c_a3355351c471c88039bef49a658c06109_cgraph" id="flowy_8c_a3355351c471c88039bef49a658c06109_cgraph">
<area shape="rect" id="node3" href="iterate_8c.html#a6d88d48d220e95a90623fd364a7ff51b" title="iter_init" alt="" coords="121,5,185,33"/><area shape="rect" id="node5" href="iterate_8c.html#a38a5dc6c2c0cc8a9d328a076e92e2d52" title="iter_next" alt="" coords="117,57,190,85"/></map>
</div>
</p>

</div>
</div>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 22 2012 20:25:16 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
