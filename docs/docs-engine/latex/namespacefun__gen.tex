\hypertarget{namespacefun__gen}{\section{fun\-\_\-gen \-Namespace \-Reference}
\label{namespacefun__gen}\index{fun\-\_\-gen@{fun\-\_\-gen}}
}
\subsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespacefun__gen_a61a94a55994d4646e00b38ca77db4b61}{filter\-\_\-body}
\item 
def \hyperlink{namespacefun__gen_af701bf481b8c50cf36062b91d0059cf7}{grouper\-\_\-body}
\item 
def \hyperlink{namespacefun__gen_ab9d83814c07cea2f7b79b84210c52cc7}{groupaggr\-\_\-body}
\item 
def \hyperlink{namespacefun__gen_a4e976e87c1e7c326e1befa11a8d26a44}{gfilter\-\_\-body}
\item 
def \hyperlink{namespacefun__gen_ac739eab321bbc8f1a6e257754772409c}{merger\-\_\-body}
\item 
def \hyperlink{namespacefun__gen_a0820d7a5d4a6756120f938f26520b49d}{switch\-\_\-cases}
\end{DoxyCompactItemize}
\subsection*{\-Variables}
\begin{DoxyCompactItemize}
\item 
dictionary \hyperlink{namespacefun__gen_ab0aa9bb5cee4f4de9db0a8276db1fc7f}{operation\-\_\-map}
\item 
dictionary \hyperlink{namespacefun__gen_a3f0fc2c7eb9b8116260fdfe608911309}{enum\-\_\-map}
\item 
string \hyperlink{namespacefun__gen_ab2fbbcc4262280e33d3bd590dd2fc198}{preamble}
\item 
tuple \hyperlink{namespacefun__gen_a6ae1f74cc5476582c44a74abfd58b9da}{header} = open(\char`\"{}auto\-\_\-comps.\-h\char`\"{}, 'w')
\item 
tuple \hyperlink{namespacefun__gen_a731fe5a5826f22d63eb10f7b75e684aa}{source} = open(\char`\"{}auto\-\_\-comps.\-c\char`\"{}, \char`\"{}w\char`\"{})
\item 
string \hyperlink{namespacefun__gen_aeb238801eab5d97517c3bfecab2e88b8}{filter\-\_\-proto} = \char`\"{}bool filter\-\_\-\%s\-\_\-\%s(char $\ast$record, size\-\_\-t field\-\_\-offset, uint64\-\_\-t value, uint64\-\_\-t delta)\char`\"{}
\item 
string \hyperlink{namespacefun__gen_a73685c5a808b19d3a0d239c25fbf1bde}{grouper\-\_\-proto} = \char`\"{}bool grouper\-\_\-\%s\-\_\-\%s\-\_\-\%s\-\_\-\%s(struct \hyperlink{structgroup}{group} $\ast$\hyperlink{structgroup}{group}, size\-\_\-t field\-\_\-offset1, char $\ast$record2, size\-\_\-t field\-\_\-offset2, uint64\-\_\-t delta)\char`\"{}
\item 
string \hyperlink{namespacefun__gen_a28e6f18a249f700dbe6f13fcf12fd44a}{groupaggr\-\_\-proto} = \char`\"{}struct \hyperlink{structaggr}{aggr} aggr\-\_\-\%s\-\_\-\%s(char $\ast$$\ast$records, size\-\_\-t num\-\_\-records, size\-\_\-t field\-\_\-offset)\char`\"{}
\item 
string \hyperlink{namespacefun__gen_a009fbfb14aad3d2d0322096cd19691f9}{gfilter\-\_\-proto} = \char`\"{}bool gfilter\-\_\-\%s(struct \hyperlink{structgroup}{group} $\ast$\hyperlink{structgroup}{group}, size\-\_\-t field, uint64\-\_\-t value, uint64\-\_\-t delta)\char`\"{}
\item 
string \hyperlink{namespacefun__gen_aaea004d0d849466492a010a6a527388b}{merger\-\_\-proto} = \char`\"{}bool merger\-\_\-\%s(struct \hyperlink{structgroup}{group} $\ast$group1, size\-\_\-t field1, struct \hyperlink{structgroup}{group} $\ast$group2, size\-\_\-t field2, uint64\-\_\-t delta)\char`\"{}
\end{DoxyCompactItemize}


\subsection{\-Function \-Documentation}
\hypertarget{namespacefun__gen_a61a94a55994d4646e00b38ca77db4b61}{\index{fun\-\_\-gen@{fun\-\_\-gen}!filter\-\_\-body@{filter\-\_\-body}}
\index{filter\-\_\-body@{filter\-\_\-body}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{filter\-\_\-body}]{\setlength{\rightskip}{0pt plus 5cm}def {\bf fun\-\_\-gen.\-filter\-\_\-body} (
\begin{DoxyParamCaption}
\item[{}]{op, }
\item[{}]{atype}
\end{DoxyParamCaption}
)}}\label{namespacefun__gen_a61a94a55994d4646e00b38ca77db4b61}

\begin{DoxyCode}
94 
95 def filter_body(op, atype):
96     result = "\n{\n"
97     if op == "eq":
98         result += "    %s rec = *(%s *)(record + field_offset);\n"%(atype, 
      atype)
99         result += "    return (rec >= value - delta) && (rec <= value + delta);
      \n"
100     elif op == "ne":
101         result += "    %s rec = *(%s *)(record + field_offset);\n"%(atype, 
      atype)
102         result += "    return (rec < value - delta) || (rec > value + delta);\n
      ";
103     elif op in ['lt', 'le']:
104         result += "    return *(%s *)(record + field_offset) %s value + delta;
      \n"%(atype, operation_map[op])
105     elif op in ['gt', 'ge']:
106         result += "    return *(%s *)(record + field_offset) %s value - delta;
      \n"%(atype, operation_map[op])
107     else:
108         raise ValueError(op)
109     result += "}\n\n"
110     return result

\end{DoxyCode}
\hypertarget{namespacefun__gen_a4e976e87c1e7c326e1befa11a8d26a44}{\index{fun\-\_\-gen@{fun\-\_\-gen}!gfilter\-\_\-body@{gfilter\-\_\-body}}
\index{gfilter\-\_\-body@{gfilter\-\_\-body}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{gfilter\-\_\-body}]{\setlength{\rightskip}{0pt plus 5cm}def {\bf fun\-\_\-gen.\-gfilter\-\_\-body} (
\begin{DoxyParamCaption}
\item[{}]{op}
\end{DoxyParamCaption}
)}}\label{namespacefun__gen_a4e976e87c1e7c326e1befa11a8d26a44}

\begin{DoxyCode}
295 
296 def gfilter_body(op):
297     result = "\n{\n"
298     result += "    if (group->aggr[field].num_values == 0) {\n"
299     result += "        return false;\n"
300     result += "    }\n"
301     if op == "eq":
302         result += "    return (group->aggr[field].values[0] >= value - delta)
       && (group->aggr[field].values[0] <= value + delta);\n"
303     elif op == "ne":
304         result += "    return (group->aggr[field].values[0] < value - delta) ||
       (group->aggr[field].values[0] > value + delta);\n";
305     elif op in ['lt', 'le']:
306         result += "    return group->aggr[field].values[0] %s value + delta;\n"
      %operation_map[op]
307     elif op in ['gt', 'ge']:
308         result += "    return group->aggr[field].values[0] %s value - delta;\n"
      %operation_map[op]
309     else:
310         raise ValueError(op)
311     result += "}\n\n"
312     return result

\end{DoxyCode}
\hypertarget{namespacefun__gen_ab9d83814c07cea2f7b79b84210c52cc7}{\index{fun\-\_\-gen@{fun\-\_\-gen}!groupaggr\-\_\-body@{groupaggr\-\_\-body}}
\index{groupaggr\-\_\-body@{groupaggr\-\_\-body}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{groupaggr\-\_\-body}]{\setlength{\rightskip}{0pt plus 5cm}def {\bf fun\-\_\-gen.\-groupaggr\-\_\-body} (
\begin{DoxyParamCaption}
\item[{}]{op, }
\item[{}]{atype}
\end{DoxyParamCaption}
)}}\label{namespacefun__gen_ab9d83814c07cea2f7b79b84210c52cc7}

\begin{DoxyCode}
154 
155 def groupaggr_body(op, atype):
156     result = "\n{\n"
157     result += "    struct aggr aggr;\n"
158     result += "    if (num_records == 0) {\n"
159     result += "        aggr.num_values = 0;\n"
160     result += "        aggr.values = NULL;\n"
161     result += "        return aggr;\n"
162     result += "    }\n"
163     if op == 'static':
164         result += "    aggr.num_values = 1;\n"
165         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
166         result += "    if (aggr.values == NULL) {\n"
167         result += "        perror(\"malloc\");\n"
168         result += "    }\n"
169         result += "    aggr.values[0] = *(%s *)(records[0] + field_offset);\n"%
      atype
170     elif op == 'count':
171         result += "    aggr.num_values = 1;\n"
172         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
173         result += "    if (aggr.values == NULL) {\n"
174         result += "        perror(\"malloc\");\n"
175         result += "    }\n"
176         result += "    aggr.values[0] = num_records;\n"
177     elif op in ['prod', 'sum', 'and', 'or', 'xor']:
178         result += "    int i;\n"
179         result += "    aggr.num_values = 1;\n"
180         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
181         result += "    if (aggr.values == NULL) {\n"
182         result += "        perror(\"malloc\");\n"
183         result += "    }\n"
184         result += "    for (i = 0; i < num_records; i++) {\n"
185         result += "        aggr.values[0] %s= *(%s *)(records[i] +
       field_offset);\n"%(operation_map[op], atype)
186         result += "    }\n"
187     elif op == 'mean':
188         result += "    int i;\n"
189         result += "    aggr.num_values = 1;\n"
190         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
191         result += "    if (aggr.values == NULL) {\n"
192         result += "        perror(\"malloc\");\n"
193         result += "    }\n"
194         result += "    for (i = 0; i < num_records; i++) {\n"
195         result += "        aggr.values[0] += *(%s *)(records[i] +
       field_offset);\n"%atype
196         result += "    }\n"
197         result += "    aggr.values[0] /= num_records;\n"
198     elif op == 'stddev':
199         result += "    int i;\n"
200         result += "    uint64_t stddev;\n"
201         result += "    aggr.num_values = 1;\n"
202         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
203         result += "    if (aggr.values == NULL) {\n"
204         result += "        perror(\"malloc\");\n"
205         result += "    }\n"
206         result += "    for (i = 0; i < num_records; i++) {\n"
207         result += "        aggr.values[0] += *(%s *)(records[i] +
       field_offset);\n"%atype
208         result += "    }\n"
209         result += "    aggr.values[0] /= num_records;\n"
210         result += "    for (i = 0; i < num_records; i++) {\n"
211         result += "        stddev += (*(%s *)(records[i] +
       field_offset)-aggr.values[0])*(*(%s *)(records[i] + field_offset)-aggr.values[0]);\n"%(atype, atype)
212         result += "    }\n"
213         result += "    stddev /= num_records;\n"
214         result += "    stddev = sqrt(stddev);\n"
215     elif op == 'union':
216         result += "    int i;\n"
217         result += "    uint64_t *temp;\n"
218         result += "    uint64_t last;\n"
219         result += "    temp = (uint64_t *)malloc(sizeof(uint64_t)*num_records);
      \n"
220         result += "    if (temp == NULL) {\n"
221         result += "        perror(\"malloc\");\n"
222         result += "    }\n"
223         result += "    for (i=0; i < num_records; i++) {\n"
224         result += "        temp[i] = *(%s *)(records[i] + field_offset);\n"%
      atype
225         result += "    }\n"
226         result += "    qsort(temp, num_records, sizeof(uint64_t), compar);\n"
227         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*num_records);\n"
228         result += "    if (aggr.values == NULL) {\n"
229         result += "        perror(\"malloc\");\n"
230         result += "    }\n"
231         result += "    aggr.values[0] = temp[0];\n"
232         result += "    last = temp[0];\n"
233         result += "    aggr.num_values = 1;\n"
234         result += "    for (i=1; i < num_records; i++) {\n"
235         result += "        if (temp[i] != last) {\n"
236         result += "            aggr.values[aggr.num_values++] = temp[i];\n"
237         result += "            last = temp[i];\n"
238         result += "        }\n"
239         result += "    }\n"
240         result += "    aggr.values = (uint64_t *)realloc(aggr.values,
       sizeof(uint64_t)*aggr.num_values);\n"
241         result += "    if (aggr.values == NULL) {\n"
242         result += "        perror(\"malloc\");\n"
243         result += "    }\n"
244         result += "    free(temp);\n"
245     elif op == 'median':
246         result += "    int i;\n"
247         result += "    uint64_t *temp;\n"
248         result += "    temp = (uint64_t *)malloc(sizeof(uint64_t)*num_records);
      \n"
249         result += "    if (temp == NULL) {\n"
250         result += "        perror(\"malloc\");\n"
251         result += "    }\n"
252         result += "    for (i=0; i < num_records; i++) {\n"
253         result += "        temp[i] = *(%s *)(records[i] + field_offset);\n"%
      atype
254         result += "    }\n"
255         result += "    qsort(temp, num_records, sizeof(uint64_t), compar);\n"
256         result += "    aggr.num_values = 1;\n"
257         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
258         result += "    if (aggr.values == NULL) {\n"
259         result += "        perror(\"malloc\");\n"
260         result += "    }\n"
261         result += "    aggr.values[0] = temp[num_records/2];"
262         result += "    free(temp);\n"
263     elif op == 'min':
264         result += "    int i;\n"
265         result += "    aggr.num_values = 1;\n"
266         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
267         result += "    if (aggr.values == NULL) {\n"
268         result += "        perror(\"malloc\");\n"
269         result += "    }\n"
270         result += "    aggr.values[0] = *(%s *)(records[0] + field_offset);\n"%
      atype
271         result += "    for (i = 1; i < num_records; i++) {\n"
272         result += "        if (*(%s *)(records[0] + field_offset) <
       aggr.values[0]) {\n"%atype
273         result += "            aggr.values[0] = *(%s *)(records[0] +
       field_offset);\n"%atype
274         result += "        }\n"
275         result += "    }\n"
276     elif op == 'max':
277         result += "    int i;\n"
278         result += "    aggr.num_values = 1;\n"
279         result += "    aggr.values = (uint64_t
       *)malloc(sizeof(uint64_t)*aggr.num_values);\n"
280         result += "    if (aggr.values == NULL) {\n"
281         result += "        perror(\"malloc\");\n"
282         result += "    }\n"
283         result += "    aggr.values[0] = *(%s *)(records[0] + field_offset);\n"%
      atype
284         result += "    for (i = 1; i < num_records; i++) {\n"
285         result += "        if (*(%s *)(records[0] + field_offset) >
       aggr.values[0]) {\n"%atype
286         result += "            aggr.values[0] = *(%s *)(records[0] +
       field_offset);\n"%atype
287         result += "        }\n"
288         result += "    }\n"
289     else:
290         raise ValueError(op)
291     result += "    return aggr;\n"
292     result += "}\n\n"
293     return result

\end{DoxyCode}
\hypertarget{namespacefun__gen_af701bf481b8c50cf36062b91d0059cf7}{\index{fun\-\_\-gen@{fun\-\_\-gen}!grouper\-\_\-body@{grouper\-\_\-body}}
\index{grouper\-\_\-body@{grouper\-\_\-body}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{grouper\-\_\-body}]{\setlength{\rightskip}{0pt plus 5cm}def {\bf fun\-\_\-gen.\-grouper\-\_\-body} (
\begin{DoxyParamCaption}
\item[{}]{op, }
\item[{}]{atype1, }
\item[{}]{atype2, }
\item[{}]{dtype}
\end{DoxyParamCaption}
)}}\label{namespacefun__gen_af701bf481b8c50cf36062b91d0059cf7}

\begin{DoxyCode}
112 
113 def grouper_body(op, atype1, atype2, dtype):
114     result = "\n{\n"
115     if op == "eq":
116         if dtype == 'no':
117             result += "    return *(%s *)(group->members[0] + field_offset1) ==
       *(%s *)(record2 + field_offset2);\n"%(atype1, atype2)
118         else:
119             if dtype == 'rel':
120                 result += "    %s rec1 = *(%s
       *)(group->members[group->num_members-1] + field_offset1);\n"%(atype1, atype1)
121             else:
122                 result += "    %s rec1 = *(%s *)(group->members[0] +
       field_offset1);\n"%(atype1, atype1)
123             result += "    %s rec2 = *(%s *)(record2 + field_offset2);\n"%(
      atype2, atype2)
124             result += "    return (rec1 >= rec2 - delta) && (rec1 <= rec2 +
       delta);\n"
125     elif op == "ne":
126         if dtype == 'no':
127             result += "    return *(%s *)(group->members[0] + field_offset1) !=
       *(%s *)(record2 + field_offset2);\n"%(atype1, atype2)
128         else:
129             if dtype == 'rel':
130                 result += "    %s rec1 = *(%s
       *)(group->members[group->num_members-1] + field_offset1);\n"%(atype1, atype1)
131             else:
132                 result += "    %s rec1 = *(%s *)(group->members[0] +
       field_offset1);\n"%(atype1, atype1)
133             result += "    %s rec2 = *(%s *)(record2 + field_offset2);\n"%(
      atype2, atype2)
134             result += "    return (rec1 < rec2 - delta) || (rec1 > rec2 +
       delta);\n"
135     elif op in ['lt', 'le']:
136         if dtype == 'no':
137             result += "    return *(%s *)(group->members[0] + field_offset1) %s
       *(%s *)(record2 + field_offset2);\n"%(atype1, operation_map[op], atype2)
138         elif dtype == 'rel':
139             result += "    return *(%s *)(group->members[group->num_members-1]
       + field_offset1) %s *(%s *)(record2 + field_offset2) + delta;\n"%(atype1, 
      operation_map[op], atype2)
140         else:
141             result += "    return *(%s *)(group->members[0] + field_offset1) %s
       *(%s *)(record2 + field_offset2) + delta;\n"%(atype1, operation_map[op], atype2
      )
142     elif op in ['gt', 'ge']:
143         if dtype == 'no':
144             result += "    return *(%s *)(group->members[0] + field_offset1) %s
       *(%s *)(record2 + field_offset2);\n"%(atype1, operation_map[op], atype2)
145         if dtype == 'rel':
146             result += "    return *(%s *)(group->members[group->num_members-1]
       + field_offset1) %s *(%s *)(record2 + field_offset2) - delta;\n"%(atype1, 
      operation_map[op], atype2)
147         else:
148             result += "    return *(%s *)(group->members[0] + field_offset1) %s
       *(%s *)(record2 + field_offset2) - delta;\n"%(atype1, operation_map[op], atype2
      )
149     else:
150         raise ValueError(op)
151     result += "}\n\n"
152     return result;

\end{DoxyCode}
\hypertarget{namespacefun__gen_ac739eab321bbc8f1a6e257754772409c}{\index{fun\-\_\-gen@{fun\-\_\-gen}!merger\-\_\-body@{merger\-\_\-body}}
\index{merger\-\_\-body@{merger\-\_\-body}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{merger\-\_\-body}]{\setlength{\rightskip}{0pt plus 5cm}def {\bf fun\-\_\-gen.\-merger\-\_\-body} (
\begin{DoxyParamCaption}
\item[{}]{op}
\end{DoxyParamCaption}
)}}\label{namespacefun__gen_ac739eab321bbc8f1a6e257754772409c}

\begin{DoxyCode}
314 
315 def merger_body(op):
316     result = "\n{\n"
317     if op in ['eq', 'ne', 'lt', 'gt', 'le', 'ge', 'in']:
318         result += "    if (group1->aggr[field1].num_values == 0 ||
       group2->aggr[field2].num_values == 0) {\n"
319         result += "        return false;\n"
320         result += "    }\n"
321     if op == "eq":
322         result += "    return (group1->aggr[field1].values[0] >=
       group2->aggr[field2].values[0] - delta) && (group1->aggr[field1].values[0] <=
       group2->aggr[field2].values[0] + delta);\n"
323     elif op == "ne":
324         result += "    return (group1->aggr[field1].values[0] <
       group2->aggr[field2].values[0] - delta) || (group1->aggr[field1].values[0] >
       group2->aggr[field2].values[0] + delta);\n"
325     elif op in ['lt', 'le']:
326         result += "    return group1->aggr[field1].values[0] %s
       group2->aggr[field2].values[0] + delta;\n"%operation_map[op]
327     elif op in ['gt', 'ge']:
328         result += "    return group1->aggr[field1].values[0] %s
       group2->aggr[field2].values[0] - delta;\n"%operation_map[op]
329     elif op == 'a_bf':
330         result += "    return group1->end < group2->start;\n"
331     elif op == 'a_af':
332         result += "    return group1->start > group2->end;\n"
333     elif op == 'a_m':
334         result += "    return group1->end == group2->start;\n"
335     elif op == 'a_mi':
336         result += "    return group1->start == group2->end;\n"
337     elif op == 'a_o':
338         result += "    return group1->start < group2->start && group1->end >
       group2->start;\n"
339     elif op == 'a_oi':
340         result += "    return group1->end > group2->end && group1->start <
       group2->end;\n"
341     elif op == 'a_s':
342         result += "    return group1->start == group2->start && group1->end <
       group2->end;\n"
343     elif op == 'a_si':
344         result += "    return group1->start == group2->start && group1->end >
       group2->end;\n"
345     elif op == 'a_d':
346         result += "    return group1->start > group2->start && group1->end <
       group2->end;\n"
347     elif op == 'a_di':
348         result += "    return group1->start < group2->start && group1->end >
       group2->end;\n"
349     elif op == 'a_f':
350         result += "    return group1->end == group2->end && group1->start >
       group2->start;\n"
351     elif op == 'a_fi':
352         result += "    return group1->end == group2->end && group1->start <
       group2->start;\n"
353     elif op == 'a_eq':
354         result += "    return group1->start == group2->start && group1->end ==
       group2->end;\n"
355     elif op == 'in':
356         result += "    int i;\n"
357         result += "    for (i=0; i<group2->aggr[field2].num_values; i++) {\n"
358         result += "        if (group1->aggr[field1].values[0] >=
       group2->aggr[field2].values[i] - delta && group1->aggr[field1].values[0] <=
       group2->aggr[field2].values[i] + delta) {\n"
359         result += "            return true;\n"
360         result += "        }\n"
361         result += "    }\n"
362         result += "    return false;\n"
363     else:
364         raise ValueError(op)
365     result += "}\n\n"
366     return result;
367 
# filter
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespacefun__gen_ac739eab321bbc8f1a6e257754772409c_cgraph}
\end{center}
\end{figure}


\hypertarget{namespacefun__gen_a0820d7a5d4a6756120f938f26520b49d}{\index{fun\-\_\-gen@{fun\-\_\-gen}!switch\-\_\-cases@{switch\-\_\-cases}}
\index{switch\-\_\-cases@{switch\-\_\-cases}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{switch\-\_\-cases}]{\setlength{\rightskip}{0pt plus 5cm}def {\bf fun\-\_\-gen.\-switch\-\_\-cases} (
\begin{DoxyParamCaption}
\item[{}]{op, }
\item[{}]{atype1, }
\item[{}]{atype2, }
\item[{}]{dtype}
\end{DoxyParamCaption}
)}}\label{namespacefun__gen_a0820d7a5d4a6756120f938f26520b49d}

\begin{DoxyCode}
443 
444 def switch_cases(op, atype1, atype2, dtype):
445     result = ""
446     if op == "eq":
447         if dtype == 'no':
448             result += "    rule_matches = (*(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1) == *(%s *)(**record_iter +
       group_modules[k].field_offset2));\n"%(atype1, atype2)
449         else:
450             if dtype == 'rel':
451                 result += "    rec1_%s = *(%s
       *)(newgroup->members[newgroup->num_members-1] + group_modules[k].field_offset1);\n"%(atype1, atype1)
452             else:
453                 result += "    rec1_%s = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1);\n"%(atype1, atype1)
454             result += "    rec2_%s = *(%s *)(**record_iter +
       group_modules[k].field_offset2);\n"%(atype2, atype2)
455             result += "    rule_matches = (rec1_%s >= rec2_%s -
       group_modules[k].delta) && (rec1_%s <= rec2_%s + group_modules[k].delta);\n"%(atype1, atype2, 
      atype1, atype2)
456     elif op == "ne":
457         if dtype == 'no':
458             result += "    rule_matches = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1) != *(%s *)(**record_iter +
       group_modules[k].field_offset2);\n"%(atype1, atype2)
459         else:
460             if dtype == 'rel':
461                 result += "    rec1_%s = *(%s
       *)(newgroup->members[newgroup->num_members-1] + group_modules[k].field_offset1);\n"%(atype1, atype1)
462             else:
463                 result += "    rec1_%s = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1);\n"%(atype1, atype1)
464             result += "    rec2_%s = *(%s *)(**record_iter +
       group_modules[k].field_offset2);\n"%(atype2, atype2)
465             result += "    rule_matches = (rec1_%s < rec2_%s -
       group_modules[k].delta) || (rec1_%s > rec2_%s + group_modules[k].delta);\n"%(atype1, atype2, 
      atype1, atype2)
466     elif op in ['lt', 'le']:
467         if dtype == 'no':
468             result += "    rule_matches = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1) %s *(%s *)(**record_iter +
       group_modules[k].field_offset2);\n"%(atype1, operation_map[op], atype2)
469         elif dtype == 'rel':
470             result += "    rule_matches = *(%s
       *)(newgroup->members[newgroup->num_members-1] + group_modules[k].field_offset1) %s *(%s *)(**record_iter +
       group_modules[k].field_offset2) + group_modules[k].delta;\n"%(atype1, operation_map[
      op], atype2)
471         else:
472             result += "    rule_matches = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1) %s *(%s *)(**record_iter +
       group_modules[k].field_offset2) + group_modules[k].delta;\n"%(atype1, operation_map[op], atype2)
473     elif op in ['gt', 'ge']:
474         if dtype == 'no':
475             result += "    rule_matches = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1) %s *(%s *)(**record_iter +
       group_modules[k].field_offset2);\n"%(atype1, operation_map[op], atype2)
476         if dtype == 'rel':
477             result += "    rule_matches = *(%s
       *)(newgroup->members[newgroup->num_members-1] + group_modules[k].field_offset1) %s *(%s *)(**record_iter +
       group_modules[k].field_offset2) - group_modules[k].delta;\n"%(atype1, operation_map[
      op], atype2)
478         else:
479             result += "    rule_matches = *(%s *)(newgroup->members[0] +
       group_modules[k].field_offset1) %s *(%s *)(**record_iter +
       group_modules[k].field_offset2) - group_modules[k].delta;\n"%(atype1, operation_map[op], atype2)
480     else:
481         raise ValueError(op)
482     return result;

\end{DoxyCode}


\subsection{\-Variable \-Documentation}
\hypertarget{namespacefun__gen_a3f0fc2c7eb9b8116260fdfe608911309}{\index{fun\-\_\-gen@{fun\-\_\-gen}!enum\-\_\-map@{enum\-\_\-map}}
\index{enum\-\_\-map@{enum\-\_\-map}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{enum\-\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}dictionary {\bf fun\-\_\-gen\-::enum\-\_\-map}}}\label{namespacefun__gen_a3f0fc2c7eb9b8116260fdfe608911309}
{\bfseries \-Initial value\-:}
\begin{DoxyCode}
1 {
2     'RULE_S2_8': 'uint8_t',
3     'RULE_S2_16': 'uint16_t',
4     'RULE_S2_32': 'uint32_t',
5     'RULE_S2_64': 'uint64_t',
6     'RULE_S1_8': 'uint8_t',
7     'RULE_S1_16': 'uint16_t',
8     'RULE_S1_32': 'uint32_t',
9     'RULE_S1_64': 'uint64_t',
10     'RULE_ABS': 'abs',
11     'RULE_REL': 'rel',
12     'RULE_NO': 'no',
13     'RULE_EQ': 'eq',
14     'RULE_NE': 'ne',
15     'RULE_GT': 'gt',
16     'RULE_LT': 'lt',
17     'RULE_LE': 'le',
18     'RULE_GE': 'ge',
19 }
\end{DoxyCode}
\hypertarget{namespacefun__gen_aeb238801eab5d97517c3bfecab2e88b8}{\index{fun\-\_\-gen@{fun\-\_\-gen}!filter\-\_\-proto@{filter\-\_\-proto}}
\index{filter\-\_\-proto@{filter\-\_\-proto}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{filter\-\_\-proto}]{\setlength{\rightskip}{0pt plus 5cm}string {\bf fun\-\_\-gen\-::filter\-\_\-proto} = \char`\"{}bool filter\-\_\-\%s\-\_\-\%s(char $\ast$record, size\-\_\-t field\-\_\-offset, uint64\-\_\-t value, uint64\-\_\-t delta)\char`\"{}}}\label{namespacefun__gen_aeb238801eab5d97517c3bfecab2e88b8}
\hypertarget{namespacefun__gen_a009fbfb14aad3d2d0322096cd19691f9}{\index{fun\-\_\-gen@{fun\-\_\-gen}!gfilter\-\_\-proto@{gfilter\-\_\-proto}}
\index{gfilter\-\_\-proto@{gfilter\-\_\-proto}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{gfilter\-\_\-proto}]{\setlength{\rightskip}{0pt plus 5cm}string {\bf fun\-\_\-gen\-::gfilter\-\_\-proto} = \char`\"{}bool gfilter\-\_\-\%s(struct {\bf group} $\ast${\bf group}, size\-\_\-t field, uint64\-\_\-t value, uint64\-\_\-t delta)\char`\"{}}}\label{namespacefun__gen_a009fbfb14aad3d2d0322096cd19691f9}
\hypertarget{namespacefun__gen_a28e6f18a249f700dbe6f13fcf12fd44a}{\index{fun\-\_\-gen@{fun\-\_\-gen}!groupaggr\-\_\-proto@{groupaggr\-\_\-proto}}
\index{groupaggr\-\_\-proto@{groupaggr\-\_\-proto}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{groupaggr\-\_\-proto}]{\setlength{\rightskip}{0pt plus 5cm}string {\bf fun\-\_\-gen\-::groupaggr\-\_\-proto} = \char`\"{}struct {\bf aggr} aggr\-\_\-\%s\-\_\-\%s(char $\ast$$\ast$records, size\-\_\-t num\-\_\-records, size\-\_\-t field\-\_\-offset)\char`\"{}}}\label{namespacefun__gen_a28e6f18a249f700dbe6f13fcf12fd44a}
\hypertarget{namespacefun__gen_a73685c5a808b19d3a0d239c25fbf1bde}{\index{fun\-\_\-gen@{fun\-\_\-gen}!grouper\-\_\-proto@{grouper\-\_\-proto}}
\index{grouper\-\_\-proto@{grouper\-\_\-proto}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{grouper\-\_\-proto}]{\setlength{\rightskip}{0pt plus 5cm}string {\bf fun\-\_\-gen\-::grouper\-\_\-proto} = \char`\"{}bool grouper\-\_\-\%s\-\_\-\%s\-\_\-\%s\-\_\-\%s(struct {\bf group} $\ast${\bf group}, size\-\_\-t field\-\_\-offset1, char $\ast$record2, size\-\_\-t field\-\_\-offset2, uint64\-\_\-t delta)\char`\"{}}}\label{namespacefun__gen_a73685c5a808b19d3a0d239c25fbf1bde}
\hypertarget{namespacefun__gen_a6ae1f74cc5476582c44a74abfd58b9da}{\index{fun\-\_\-gen@{fun\-\_\-gen}!header@{header}}
\index{header@{header}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{header}]{\setlength{\rightskip}{0pt plus 5cm}tuple {\bf fun\-\_\-gen\-::header} = open(\char`\"{}auto\-\_\-comps.\-h\char`\"{}, 'w')}}\label{namespacefun__gen_a6ae1f74cc5476582c44a74abfd58b9da}
\hypertarget{namespacefun__gen_aaea004d0d849466492a010a6a527388b}{\index{fun\-\_\-gen@{fun\-\_\-gen}!merger\-\_\-proto@{merger\-\_\-proto}}
\index{merger\-\_\-proto@{merger\-\_\-proto}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{merger\-\_\-proto}]{\setlength{\rightskip}{0pt plus 5cm}string {\bf fun\-\_\-gen\-::merger\-\_\-proto} = \char`\"{}bool merger\-\_\-\%s(struct {\bf group} $\ast$group1, size\-\_\-t field1, struct {\bf group} $\ast$group2, size\-\_\-t field2, uint64\-\_\-t delta)\char`\"{}}}\label{namespacefun__gen_aaea004d0d849466492a010a6a527388b}
\hypertarget{namespacefun__gen_ab0aa9bb5cee4f4de9db0a8276db1fc7f}{\index{fun\-\_\-gen@{fun\-\_\-gen}!operation\-\_\-map@{operation\-\_\-map}}
\index{operation\-\_\-map@{operation\-\_\-map}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{operation\-\_\-map}]{\setlength{\rightskip}{0pt plus 5cm}dictionary {\bf fun\-\_\-gen\-::operation\-\_\-map}}}\label{namespacefun__gen_ab0aa9bb5cee4f4de9db0a8276db1fc7f}
{\bfseries \-Initial value\-:}
\begin{DoxyCode}
1 {
2     'eq': '==',
3     'ne': '!=',
4     'lt': '<',
5     'gt': '>',
6     'le': '<=',
7     'ge': '>=',
8     'prod': '*',
9     'sum': '+',
10     'and': '&',
11     'or': '|',
12     'xor': '^'
13 }
\end{DoxyCode}
\hypertarget{namespacefun__gen_ab2fbbcc4262280e33d3bd590dd2fc198}{\index{fun\-\_\-gen@{fun\-\_\-gen}!preamble@{preamble}}
\index{preamble@{preamble}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{preamble}]{\setlength{\rightskip}{0pt plus 5cm}string {\bf fun\-\_\-gen\-::preamble}}}\label{namespacefun__gen_ab2fbbcc4262280e33d3bd590dd2fc198}
{\bfseries \-Initial value\-:}
\begin{DoxyCode}
1 """
2 /*
3  * This file was automatically generated by %s
4  * DO NOT CHANGE!
5  */
6 
7 """
\end{DoxyCode}
\hypertarget{namespacefun__gen_a731fe5a5826f22d63eb10f7b75e684aa}{\index{fun\-\_\-gen@{fun\-\_\-gen}!source@{source}}
\index{source@{source}!fun_gen@{fun\-\_\-gen}}
\subsubsection[{source}]{\setlength{\rightskip}{0pt plus 5cm}tuple {\bf fun\-\_\-gen\-::source} = open(\char`\"{}auto\-\_\-comps.\-c\char`\"{}, \char`\"{}w\char`\"{})}}\label{namespacefun__gen_a731fe5a5826f22d63eb10f7b75e684aa}
