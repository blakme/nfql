\hypertarget{flowy_8c}{\section{flowy.\-c \-File \-Reference}
\label{flowy_8c}\index{flowy.\-c@{flowy.\-c}}
}
{\ttfamily \#include $<$stdio.\-h$>$}\*
{\ttfamily \#include $<$pthread.\-h$>$}\*
{\ttfamily \#include $<$stdlib.\-h$>$}\*
{\ttfamily \#include $<$errno.\-h$>$}\*
{\ttfamily \#include $<$stdbool.\-h$>$}\*
{\ttfamily \#include $<$string.\-h$>$}\*
{\ttfamily \#include \char`\"{}ftreader.\-h\char`\"{}}\*
{\ttfamily \#include \char`\"{}flowy.\-h\char`\"{}}\*
{\ttfamily \#include \char`\"{}auto\-\_\-comps.\-h\char`\"{}}\*
{\ttfamily \#include \char`\"{}utils.\-h\char`\"{}}\*
\-Include dependency graph for flowy.\-c\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{flowy_8c__incl}
\end{center}
\end{figure}
\subsection*{\-Defines}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{flowy_8c_a369266c24eacffb87046522897a570d5}{\-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E}
\end{DoxyCompactItemize}
\subsection*{\-Functions}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structgroup}{group} $\ast$$\ast$ \hyperlink{flowy_8c_aa035e73fc4c57220877467d56e352ee1}{grouper} (char $\ast$$\ast$filtered\-\_\-records, size\-\_\-t num\-\_\-filtered\-\_\-records, struct \hyperlink{structgrouper__rule}{grouper\-\_\-rule} $\ast$group\-\_\-modules, int num\-\_\-group\-\_\-modules, struct \hyperlink{structgrouper__aggr}{grouper\-\_\-aggr} $\ast$\hyperlink{structaggr}{aggr}, size\-\_\-t num\-\_\-group\-\_\-aggr, size\-\_\-t $\ast$num\-\_\-groups)
\item 
struct \hyperlink{structgroup}{group} $\ast$$\ast$$\ast$ \hyperlink{flowy_8c_a3355351c471c88039bef49a658c06109}{merger} (struct \hyperlink{structgroup}{group} $\ast$$\ast$$\ast$filtered\-\_\-groups, size\-\_\-t $\ast$num\-\_\-filtered\-\_\-groups, int num\-\_\-threads, struct \hyperlink{structmerger__rule}{merger\-\_\-rule} $\ast$\hyperlink{flowy_8c_ad16d168606f8e5927810013c8b566b3a}{filter}, int num\-\_\-filter\-\_\-rules)
\item 
char $\ast$$\ast$ \hyperlink{flowy_8c_ad16d168606f8e5927810013c8b566b3a}{filter} (struct \hyperlink{structft__data}{ft\-\_\-data} $\ast$data, struct \hyperlink{structfilter__rule}{filter\-\_\-rule} $\ast$filter\-\_\-rules, int num\-\_\-filter\-\_\-rules, size\-\_\-t $\ast$num\-\_\-filtered\-\_\-records)
\item 
struct \hyperlink{structgroup}{group} $\ast$$\ast$ \hyperlink{flowy_8c_a70f1dcae030371e286b96e41e7543dd6}{group\-\_\-filter} (struct \hyperlink{structgroup}{group} $\ast$$\ast$groups, size\-\_\-t num\-\_\-groups, struct \hyperlink{structgfilter__rule}{gfilter\-\_\-rule} $\ast$rules, size\-\_\-t num\-\_\-gfilter\-\_\-rules, size\-\_\-t $\ast$num\-\_\-filtered\-\_\-groups)
\item 
int \hyperlink{flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627}{main} (int argc, char $\ast$$\ast$argv)
\end{DoxyCompactItemize}


\subsection{\-Define \-Documentation}
\hypertarget{flowy_8c_a369266c24eacffb87046522897a570d5}{\index{flowy.\-c@{flowy.\-c}!\-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E@{\-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E}}
\index{\-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E@{\-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E}!flowy.c@{flowy.\-c}}
\subsubsection[{\-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E}]{\setlength{\rightskip}{0pt plus 5cm}\#define {\bf \-\_\-\-G\-N\-U\-\_\-\-S\-O\-U\-R\-C\-E}}}\label{flowy_8c_a369266c24eacffb87046522897a570d5}


\subsection{\-Function \-Documentation}
\hypertarget{flowy_8c_ad16d168606f8e5927810013c8b566b3a}{\index{flowy.\-c@{flowy.\-c}!filter@{filter}}
\index{filter@{filter}!flowy.c@{flowy.\-c}}
\subsubsection[{filter}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$$\ast$ {\bf filter} (
\begin{DoxyParamCaption}
\item[{struct {\bf ft\-\_\-data} $\ast$}]{data, }
\item[{struct {\bf filter\-\_\-rule} $\ast$}]{filter\-\_\-rules, }
\item[{int}]{num\-\_\-filter\-\_\-rules, }
\item[{size\-\_\-t $\ast$}]{num\-\_\-filtered\-\_\-records}
\end{DoxyParamCaption}
)}}\label{flowy_8c_ad16d168606f8e5927810013c8b566b3a}

\begin{DoxyCode}
{
    int i, j;
    char **filtered_records;

    *num_filtered_records = 0;
    filtered_records = (char **)malloc(sizeof(char *)**num_filtered_records);
    if (filtered_records == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < data->num_records; i++) {
        for (j = 0; j < num_filter_rules; j++) {
            if (!filter_rules[j].func(data->records[i], filter_rules[j].
      field_offset, filter_rules[j].value, filter_rules[j].delta))
                break;
        }

        // break if a rule did not return true
        if (j < num_filter_rules)
            continue;

        (*num_filtered_records)++;
        filtered_records = (char **)realloc(filtered_records, sizeof(char *)**
      num_filtered_records);
        if (filtered_records == NULL) {
            perror("malloc");
            exit(EXIT_FAILURE);
        }
        filtered_records[*num_filtered_records-1] = data->records[i];
    }

    return filtered_records;
}
\end{DoxyCode}
\hypertarget{flowy_8c_a70f1dcae030371e286b96e41e7543dd6}{\index{flowy.\-c@{flowy.\-c}!group\-\_\-filter@{group\-\_\-filter}}
\index{group\-\_\-filter@{group\-\_\-filter}!flowy.c@{flowy.\-c}}
\subsubsection[{group\-\_\-filter}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf group}$\ast$$\ast$ {\bf group\-\_\-filter} (
\begin{DoxyParamCaption}
\item[{struct {\bf group} $\ast$$\ast$}]{groups, }
\item[{size\-\_\-t}]{num\-\_\-groups, }
\item[{struct {\bf gfilter\-\_\-rule} $\ast$}]{rules, }
\item[{size\-\_\-t}]{num\-\_\-gfilter\-\_\-rules, }
\item[{size\-\_\-t $\ast$}]{num\-\_\-filtered\-\_\-groups}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}read\mbox{]}}}}\label{flowy_8c_a70f1dcae030371e286b96e41e7543dd6}

\begin{DoxyCode}
{
    int i, j;
    struct group **filtered_groups;

    *num_filtered_groups = 0;
    filtered_groups = (struct group **)malloc(sizeof(struct group *)**
      num_filtered_groups);

    printf("foobar3\n");
    for (i = num_groups-1; i > num_groups-10; i--) {
        printf("%p\n", groups[i]);
        if (groups[i] == NULL) {
            perror("found nil");
            exit(EXIT_FAILURE);
        }
    }

    for (i = 0; i < num_groups; i++) {
        for (j = 0; j < num_gfilter_rules; j++) {
            if (!rules[j].func(groups[i], rules[j].field, rules[j].value, rules
      [j].delta))
                break;
        }

        if (j < num_gfilter_rules) {
            free(groups[i]->members);
            free(groups[i]->aggr);
            free(groups[i]);
            groups[i] = NULL;
            continue;
        }

        (*num_filtered_groups)++;
        filtered_groups = (struct group **)realloc(filtered_groups, sizeof(
      struct group *)**num_filtered_groups);
        filtered_groups[*num_filtered_groups-1] = groups[i];
    }

    filtered_groups = (struct group **)realloc(filtered_groups, sizeof(struct 
      group *)**num_filtered_groups+1);
    if (filtered_groups == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    filtered_groups[*num_filtered_groups] = groups[i];

    printf("foobar2\n");
    for (i = *num_filtered_groups-1; i > *num_filtered_groups-10; i--) {
        printf("%p\n", filtered_groups[i]);
        if (filtered_groups[i] == NULL) {
            perror("found nil");
            exit(EXIT_FAILURE);
        }
    }

    return filtered_groups;
}
\end{DoxyCode}
\hypertarget{flowy_8c_aa035e73fc4c57220877467d56e352ee1}{\index{flowy.\-c@{flowy.\-c}!grouper@{grouper}}
\index{grouper@{grouper}!flowy.c@{flowy.\-c}}
\subsubsection[{grouper}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf group}$\ast$$\ast$ {\bf grouper} (
\begin{DoxyParamCaption}
\item[{char $\ast$$\ast$}]{filtered\-\_\-records, }
\item[{size\-\_\-t}]{num\-\_\-filtered\-\_\-records, }
\item[{struct {\bf grouper\-\_\-rule} $\ast$}]{group\-\_\-modules, }
\item[{int}]{num\-\_\-group\-\_\-modules, }
\item[{struct {\bf grouper\-\_\-aggr} $\ast$}]{aggr, }
\item[{size\-\_\-t}]{num\-\_\-group\-\_\-aggr, }
\item[{size\-\_\-t $\ast$}]{num\-\_\-groups}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}read\mbox{]}}}}\label{flowy_8c_aa035e73fc4c57220877467d56e352ee1}

\begin{DoxyCode}
{
    struct group **groups;
    struct group *newgroup;
    int i, j, k;
    struct uniq_records_tree *uniq_records_trees;

    *num_groups = 0;
    groups = (struct group **)malloc(sizeof(struct group *));

    if (num_group_modules == 0) {
        for (i = 0; i < num_filtered_records; i++) {
            if ((i&1023)==0) {
                printf("\r%0.2f%% %d/%zd groups: %zd", (i*100.0f)/
      num_filtered_records, i, num_filtered_records, *num_groups);
                fflush(stdout);
            }

            (*num_groups)++;
            groups = (struct group **)realloc(groups, sizeof(struct group*)**
      num_groups);
            newgroup = (struct group *)malloc(sizeof(struct group));
            if (newgroup == NULL) {
                perror("malloc");
                exit(EXIT_FAILURE);
            }
            groups[*num_groups-1] = newgroup;
            newgroup->num_members = 1;
            newgroup->members = (char **)malloc(sizeof(char *));
            newgroup->members[0] = filtered_records[i];
        }
    } else {
        uniq_records_trees = build_record_trees(filtered_records, 
      num_filtered_records, group_modules);

        for (i = 0; i < num_filtered_records; i++) {
            if ((i&1023)==0) {
                printf("\r%0.2f%% %d/%zd groups: %zd", (i*100.0f)/
      num_filtered_records, i, num_filtered_records, *num_groups);
                fflush(stdout);
            }

            if (filtered_records[i] == NULL)
                continue;

            (*num_groups)++;
            groups = (struct group **)realloc(groups, sizeof(struct group*)**
      num_groups);
            newgroup = (struct group *)malloc(sizeof(struct group));
            if (newgroup == NULL) {
                perror("malloc");
                exit(EXIT_FAILURE);
            }
            groups[*num_groups-1] = newgroup;
            newgroup->num_members = 1;
            newgroup->members = (char **)malloc(sizeof(char *));
            newgroup->members[0] = filtered_records[i];

            if (num_group_modules == 0)
                continue;

            // search for left hand side of comparison in records ordered by
       right
            // hand side of comparison
            char ***record_iter = ((struct tree_item_uint32_t *)bsearch_r(
                        filtered_records[i],
                        (void *)uniq_records_trees[0].uniq_records32,
                        uniq_records_trees[0].num_uniq_records,
                        sizeof(struct tree_item_uint32_t),
                        comp_uint32_t_p,
                        (void *)&group_modules[0].field_offset1))->ptr;

            // iterate until terminating NULL in sorted_records
            for (;*record_iter != NULL; record_iter++) {
                // already processed record from filtered_records
                if (**record_iter == NULL)
                    continue;

                // do not group with itself
                if (**record_iter == filtered_records[i])
                    continue;

                // check all module filter rules for those two records
                for (k = 0; k < num_group_modules; k++) {
                    if (!group_modules[k].func(newgroup, group_modules[k].
      field_offset1,
                                **record_iter, group_modules[k].field_offset2, 
      group_modules[k].delta))
                        break;
                }

                // first rule didnt match
                if (k == 0)
                    break;

                // one of the other rules didnt match
                if (k < num_group_modules)
                    continue;

                newgroup->num_members++;
                newgroup->members = (char **)realloc(newgroup->members, sizeof(
      char *)*newgroup->num_members);
                newgroup->members[newgroup->num_members-1] = **record_iter; //
       assign entry in filtered_records to group
                **record_iter = NULL; // set entry in filtered_records to NULL
            }

            filtered_records[i] = NULL;
        }

        // free uniq_records_trees
        free(uniq_records_trees[0].sorted_records);
        free(uniq_records_trees[0].uniq_records32);
        free(uniq_records_trees);
    }

    for (i = 0; i < *num_groups; i++) {
        printf("%p\n", groups[i]);
        groups[i]->aggr = (struct aggr *)malloc(sizeof(struct aggr)*
      num_group_aggr);
        if (groups[i]->aggr == NULL) {
            perror("malloc");
            exit(EXIT_FAILURE);
        }

        for (j = 0; j < num_group_aggr; j++) {
            groups[i]->aggr[j] = aggr[j].func(groups[i]->members, groups[i]->
      num_members, aggr[j].field_offset);
        }
    }

    printf("foobar5\n");
    for (i = *num_groups; i > *num_groups-10; i--) {
        printf("%p\n", groups[i]);
    }

    return groups;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{flowy_8c_aa035e73fc4c57220877467d56e352ee1_cgraph}
\end{center}
\end{figure}


\hypertarget{flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627}{\index{flowy.\-c@{flowy.\-c}!main@{main}}
\index{main@{main}!flowy.c@{flowy.\-c}}
\subsubsection[{main}]{\setlength{\rightskip}{0pt plus 5cm}int {\bf main} (
\begin{DoxyParamCaption}
\item[{int}]{argc, }
\item[{char $\ast$$\ast$}]{argv}
\end{DoxyParamCaption}
)}}\label{flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627}

\begin{DoxyCode}
{
    struct ft_data *data;
    int num_threads;
    int i, ret;
    pthread_t *thread_ids;
    pthread_attr_t *thread_attrs;
    struct branch_info *binfos;
    struct group ***filtered_groups;
    size_t *num_filtered_groups;
    struct group ***group_tuples;

    num_threads = 2;

    data = ft_open(STDIN_FILENO);

    binfos = (struct branch_info *)calloc(num_threads, sizeof(struct branch_info
      ));
    if (binfos == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    /*
     * custom rules
     */

    struct filter_rule filter_rules_branch1[1] = {
        { data->offsets.dstport, 80, 0, filter_eq_uint16_t },
    };

    struct grouper_rule group_module_branch1[2] = {
        { data->offsets.srcaddr, data->offsets.srcaddr, 0, RULE_EQ | RULE_NO | 
      RULE_S2_32 | RULE_S1_32, NULL },
        { data->offsets.dstaddr, data->offsets.dstaddr, 0, RULE_EQ | RULE_NO | 
      RULE_S2_32 | RULE_S1_32, NULL },
//        { data->offsets.Last, data->offsets.First, 1, grouper_lt_uint32_t_rel
       }
    };

    struct grouper_aggr group_aggr_branch1[4] = {
        { 0, data->offsets.srcaddr, aggr_static_uint32_t },
        { 0, data->offsets.dstaddr, aggr_static_uint32_t },
        { 0, data->offsets.dOctets, aggr_sum_uint32_t },
        { 0, data->offsets.tcp_flags, aggr_or_uint16_t }
    };

    struct gfilter_rule gfilter_branch1[0] = {
    };

    binfos[0].branch_id = 0;
    binfos[0].data = data;
    binfos[0].filter_rules = filter_rules_branch1;
    binfos[0].num_filter_rules = 0;
    binfos[0].group_modules = group_module_branch1;
    binfos[0].num_group_modules = 2;
    binfos[0].aggr = group_aggr_branch1;
    binfos[0].num_aggr = 4;
    binfos[0].gfilter_rules = gfilter_branch1;
    binfos[0].num_gfilter_rules = 0;

    struct filter_rule filter_rules_branch2[1] = {
        { data->offsets.srcport, 80, 0, filter_eq_uint16_t },
    };

    struct grouper_rule group_module_branch2[2] = {
        { data->offsets.srcaddr, data->offsets.srcaddr, 0, RULE_EQ | RULE_NO | 
      RULE_S2_32 | RULE_S1_32, NULL },
        { data->offsets.dstaddr, data->offsets.dstaddr, 0, RULE_EQ | RULE_NO | 
      RULE_S2_32 | RULE_S1_32, NULL },
//        { data->offsets.Last, data->offsets.First, 1, grouper_lt_uint32_t_rel
       },
    };

    struct grouper_aggr group_aggr_branch2[4] = {
        { 0, data->offsets.srcaddr, aggr_static_uint32_t },
        { 0, data->offsets.dstaddr, aggr_static_uint32_t },
        { 0, data->offsets.dOctets, aggr_sum_uint32_t },
        { 0, data->offsets.tcp_flags, aggr_or_uint16_t }
    };

    struct gfilter_rule gfilter_branch2[0] = {
    };

    binfos[1].branch_id = 1;
    binfos[1].data = data;
    binfos[1].filter_rules = filter_rules_branch2;
    binfos[1].num_filter_rules = 1;
    binfos[1].group_modules = group_module_branch2;
    binfos[1].num_group_modules = 2;
    binfos[1].aggr = group_aggr_branch2;
    binfos[1].num_aggr = 4;
    binfos[1].gfilter_rules = gfilter_branch2;
    binfos[1].num_gfilter_rules = 0;

    /*
     * fill the func attribute of grouper rules
     */
    assign_fptr(binfos, num_threads);

    /*
     * SPLITTER
     *
     * (mostly pthread stuff)
     */

    thread_ids = (pthread_t *)calloc(num_threads, sizeof(pthread_t));
    if (thread_ids == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    thread_attrs = (pthread_attr_t *)calloc(num_threads, sizeof(pthread_attr_t)
      );
    if (thread_attrs == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    filtered_groups = (struct group ***)malloc(num_threads*sizeof(struct group 
      **));
    if (filtered_groups == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    num_filtered_groups = (size_t *)malloc(sizeof(size_t)*num_threads);
    if (num_filtered_groups == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < num_threads; i++) {
        ret = pthread_attr_init(&thread_attrs[i]);
        if (ret != 0) {
            errno = ret;
            perror("pthread_attr_init");
            exit(EXIT_FAILURE);
        }

        ret = pthread_create(&thread_ids[i], &thread_attrs[i], &branch_start, (
      void *)(&binfos[i]));
        if (ret != 0) {
            errno = ret;
            perror("pthread_create");
            exit(EXIT_FAILURE);
        }

        ret = pthread_attr_destroy(&thread_attrs[i]);
        if (ret != 0) {
            errno = ret;
            perror("pthread_attr_destroy");
            exit(EXIT_FAILURE);
        }
    }

    for (i = 0; i < num_threads; i++) {
        ret = pthread_join(thread_ids[i], NULL);
        if (ret != 0) {
            errno = ret;
            perror("pthread_join");
            exit(EXIT_FAILURE);
        }

        num_filtered_groups[i] = binfos[i].num_filtered_groups;
        filtered_groups[i] = binfos[i].filtered_groups;
        printf("%zd\n", num_filtered_groups[i]);
    }

    free(thread_ids);
    free(thread_attrs);
    free(binfos);

    /*
     * MERGER
     */

    struct merger_rule mfilter[2] = {
        { 0, 0, 1, 1, 0, merger_eq },
        { 0, 2, 1, 2, 0, merger_lt },
    };

    printf("foobar1\n");
    for (i = num_filtered_groups[0]-1; i > num_filtered_groups[0]-10; i--) {
        printf("%p\n", filtered_groups[0][i]);
        if (filtered_groups[0][i] == NULL) {
            perror("found nil");
            exit(EXIT_FAILURE);
        }
    }

    group_tuples = merger(filtered_groups, num_filtered_groups, num_threads, 
      mfilter, 2);

    free(group_tuples);

    /*
     * UNGROUPER
     */

    // TODO: free group_collections at some point

    exit(EXIT_SUCCESS);
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{flowy_8c_a3c04138a5bfe5d72780bb7e82a18e627_cgraph}
\end{center}
\end{figure}


\hypertarget{flowy_8c_a3355351c471c88039bef49a658c06109}{\index{flowy.\-c@{flowy.\-c}!merger@{merger}}
\index{merger@{merger}!flowy.c@{flowy.\-c}}
\subsubsection[{merger}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf group}$\ast$$\ast$$\ast$ {\bf merger} (
\begin{DoxyParamCaption}
\item[{struct {\bf group} $\ast$$\ast$$\ast$}]{filtered\-\_\-groups, }
\item[{size\-\_\-t $\ast$}]{num\-\_\-filtered\-\_\-groups, }
\item[{int}]{num\-\_\-threads, }
\item[{struct {\bf merger\-\_\-rule} $\ast$}]{filter, }
\item[{int}]{num\-\_\-filter\-\_\-rules}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily  \mbox{[}read\mbox{]}}}}\label{flowy_8c_a3355351c471c88039bef49a658c06109}

\begin{DoxyCode}
{
    struct group ***group_tuples;
//    int num_group_tuples;
//    struct group **temp_tuple;
//    int i, j;
    int i;
    struct permut_iter *iter;
    size_t *offsets;

    offsets = (size_t *)malloc(sizeof(size_t)*num_threads);
    if (offsets == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }

    for (i = 0; i < num_threads; i++) offsets[i] = 0;

    iter = iter_init(offsets, num_filtered_groups, num_threads);

    printf("foobar\n");
    for (i = num_filtered_groups[0]-1; i > num_filtered_groups[0]-10; i--) {
        printf("%p\n", filtered_groups[0][i]);
        if (filtered_groups[0][i] == NULL) {
            perror("is NULL");
            exit(EXIT_FAILURE);
        }
    }

    do {
        // break if any of the groups is already grouped
        for (i = 0; i < num_threads; i++) {
            if (filtered_groups[i][iter->array[i]] == NULL) goto cont;
        }

        for (i = 0; i < num_filter_rules; i++) {
            printf("%p\n", filtered_groups[filter[i].branch1][iter->array[
      filter[i].branch1]]);
            printf("%p\n", filtered_groups[filter[i].branch1][iter->array[
      filter[i].branch1]]->aggr);
            /*
            if
       (!filter[i].func(filtered_groups[filter[i].branch1][iter->array[filter[i].branch1]], filter[i].field1,
                               
       filtered_groups[filter[i].branch2][iter->array[filter[i].branch2]], filter[i].field2,
                                filter[i].delta)) goto cont;
                                */
        }
/*
        for (i = 0; i < num_threads; i++) {
            printf("%zd ", iter->array[i]);
        }
        printf("\n");
        */

cont:   continue;
    } while (iter_next(iter));

    printf("foobar\n");
    group_tuples = NULL;
//    num_group_tuples = 0;

/*
    for (i = 0; filtered_groups[0][i]->aggr != NULL; i++) {
        for (j = 0; filtered_groups[1][j]->aggr != NULL; j++) {
            if (!filter[0].func(filtered_groups[0][i], filter[0].field1,
       filtered_groups[1][j], filter[0].field2, filter[0].delta)
                    || !filter[1].func(filtered_groups[0][i], filter[1].field1,
       filtered_groups[1][j], filter[1].field2, filter[1].delta)
                    )
                continue;

            temp_tuple = (struct group **)malloc(sizeof(struct group *)*
      num_threads);
            if (temp_tuple == NULL) {
                perror("malloc");
                exit(EXIT_FAILURE);
            }

            temp_tuple[0] = filtered_groups[0][i];
            temp_tuple[1] = filtered_groups[1][j];

            group_tuples = (struct group ***)realloc(group_tuples,
       sizeof(struct group**)*(num_group_tuples+1));
            1if (group_tuples == NULL) {
                perror("malloc");
                exit(EXIT_FAILURE);
            }

            group_tuples[num_group_tuples] = temp_tuple;
            num_group_tuples++;
        }
    }

    group_tuples = (struct group ***)realloc(group_tuples, sizeof(struct group*
      *)*(num_group_tuples+1));
    if (group_tuples == NULL) {
        perror("malloc");
        exit(EXIT_FAILURE);
    }
    group_tuples[num_group_tuples] = NULL;

    printf("number of group tuples: %d\n", num_group_tuples);

*/
    return group_tuples;
}
\end{DoxyCode}


\-Here is the call graph for this function\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=218pt]{flowy_8c_a3355351c471c88039bef49a658c06109_cgraph}
\end{center}
\end{figure}


